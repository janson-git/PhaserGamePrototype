/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"app": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./src/App.ts","vendors"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/App.ts":
/*!********************!*\
  !*** ./src/App.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Game_1 = __webpack_require__(/*! ./Game */ \"./src/Game.ts\");\nvar ObjectUtils_1 = __webpack_require__(/*! ./lib/utils/ObjectUtils */ \"./src/lib/utils/ObjectUtils.ts\");\nvar Config_1 = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\nvar App;\n(function (App) {\n    // game\n    App.game = null;\n})(App || (App = {}));\n// -------------------------------------------------------------------------\nfunction launch() {\n    return __awaiter(this, void 0, void 0, function () {\n        var configJson, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    configJson = null;\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, ObjectUtils_1.ObjectUtils.loadJson(\"assets/config.json\")];\n                case 2:\n                    configJson = _a.sent();\n                    ObjectUtils_1.ObjectUtils.loadValuesIntoObject(configJson, Config_1.Config);\n                    return [3 /*break*/, 4];\n                case 3:\n                    e_1 = _a.sent();\n                    throw e_1;\n                case 4:\n                    App.game = new Game_1.MyGame;\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nwindow.onload = launch;\n\n\n//# sourceURL=webpack:///./src/App.ts?");

/***/ }),

/***/ "./src/Components/BoatTrail.ts":
/*!*************************************!*\
  !*** ./src/Components/BoatTrail.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BoatTrail = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar BoatTrail = /** @class */ (function (_super) {\n    __extends(BoatTrail, _super);\n    function BoatTrail(scene, player) {\n        var _this = this;\n        var x = player.x;\n        var y = player.y;\n        _this = _super.call(this, scene, x, y, 'boat_trail') || this;\n        _this.player = player;\n        // Создадим анимации водного следа\n        _this.createTrailAnimations();\n        // добавляем в сцену чтобы спрайт был видим\n        _this.scene.add.existing(_this);\n        return _this;\n        // добавляем в физику, чтобы учавствовать в обсчитывании столкновений\n        // this.scene.physics.add.existing(this);\n    }\n    BoatTrail.prototype.getTailConfig = function () {\n        var halfStep = this.player.playerSpriteRotateSize / 2;\n        var directionInDeg = this.player.direction;\n        var index = 0;\n        var x = this.player.x;\n        var y = this.player.y;\n        var xDiff = 0;\n        var yDiff = 0;\n        var flipX = false;\n        var rotation = 0;\n        var oneGradInRad = Math.PI / 180;\n        if ((directionInDeg > (360 - halfStep)) || directionInDeg < halfStep) {\n            ////////////// TOP /////////////\n            index = 0;\n            xDiff = 0;\n            yDiff = 13;\n        }\n        else if ((directionInDeg > (11.25 - halfStep)) && (directionInDeg < (11.25 + halfStep))) {\n            index = 1;\n            xDiff = -4;\n            yDiff = 12;\n            rotation = -4 * (oneGradInRad);\n        }\n        else if (directionInDeg > (22.5 - halfStep) && directionInDeg < (22.5 + halfStep)) {\n            index = 1;\n            xDiff = -5;\n            yDiff = 11;\n        }\n        else if (directionInDeg > (33.75 - halfStep) && directionInDeg < (33.75 + halfStep)) {\n            index = 1;\n            xDiff = -6;\n            yDiff = 10;\n            rotation = 4 * (oneGradInRad);\n        }\n        else if (directionInDeg > (45 - halfStep) && directionInDeg < (45 + halfStep)) {\n            index = 2;\n            xDiff = -8;\n            yDiff = 7;\n        }\n        else if (directionInDeg > (56.25 - halfStep) && directionInDeg < (56.25 + halfStep)) {\n            index = 2;\n            xDiff = -10;\n            yDiff = 4;\n            rotation = 10 * (oneGradInRad);\n        }\n        else if (directionInDeg > (67.5 - halfStep) && directionInDeg < (67.5 + halfStep)) {\n            index = 3;\n            xDiff = -11;\n            yDiff = 4;\n        }\n        else if (directionInDeg > (78.75 - halfStep) && directionInDeg < (78.75 + halfStep)) {\n            index = 4;\n            xDiff = -16;\n            yDiff = 0;\n        }\n        else if (directionInDeg > (90 - halfStep) && directionInDeg < (90 + halfStep)) {\n            ////////////// RIGHT ///////////\n            index = 4;\n            xDiff = -16;\n            yDiff = 0;\n        }\n        else if (directionInDeg > (101.25 - halfStep) && directionInDeg < (101.25 + halfStep)) {\n            index = 5;\n            xDiff = -15;\n            yDiff = -4;\n            rotation = -25 * (oneGradInRad);\n        }\n        else if (directionInDeg > (112.5 - halfStep) && directionInDeg < (112.5 + halfStep)) {\n            index = 5;\n            xDiff = -12;\n            yDiff = -6;\n            rotation = -15 * (oneGradInRad);\n        }\n        else if (directionInDeg > (123.75 - halfStep) && directionInDeg < (123.75 + halfStep)) {\n            index = 6;\n            xDiff = -10;\n            yDiff = -8;\n        }\n        else if (directionInDeg > (135 - halfStep) && directionInDeg < (135 + halfStep)) {\n            index = 6;\n            xDiff = -10;\n            yDiff = -8;\n        }\n        else if (directionInDeg > (146.25 - halfStep) && directionInDeg < (146.25 + halfStep)) {\n            index = 6;\n            xDiff = -8;\n            yDiff = -8;\n        }\n        else if (directionInDeg > (157.5 - halfStep) && directionInDeg < (157.5 + halfStep)) {\n            index = 7;\n            xDiff = -5;\n            yDiff = -11;\n        }\n        else if (directionInDeg > (168.75 - halfStep) && directionInDeg < (168.75 + halfStep)) {\n            index = 7;\n            xDiff = -4;\n            yDiff = -12;\n            rotation = 4 * (oneGradInRad);\n        }\n        else if (directionInDeg > (180 - halfStep) && directionInDeg < (180 + halfStep)) {\n            ///////////// DOWN /////////////\n            index = 8;\n            xDiff = -1;\n            yDiff = -15;\n        }\n        else if (directionInDeg > (191.25 - halfStep) && directionInDeg < (191.25 + halfStep)) {\n            index = 7;\n            xDiff = 4;\n            yDiff = -12;\n            flipX = true;\n            rotation = -4 * (oneGradInRad);\n        }\n        else if (directionInDeg > (202.5 - halfStep) && directionInDeg < (202.5 + halfStep)) {\n            index = 7;\n            xDiff = 5;\n            yDiff = -11;\n            flipX = true;\n        }\n        else if (directionInDeg > (213.75 - halfStep) && directionInDeg < (213.75 + halfStep)) {\n            index = 7;\n            xDiff = 6;\n            yDiff = -11;\n            flipX = true;\n        }\n        else if (directionInDeg > (225 - halfStep) && directionInDeg < (225 + halfStep)) {\n            index = 6;\n            xDiff = 11;\n            yDiff = -8;\n            flipX = true;\n        }\n        else if (directionInDeg > (236.25 - halfStep) && directionInDeg < (236.25 + halfStep)) {\n            index = 6;\n            xDiff = 11;\n            yDiff = -8;\n            flipX = true;\n        }\n        else if (directionInDeg > (247.5 - halfStep) && directionInDeg < (247.5 + halfStep)) {\n            index = 5;\n            xDiff = 12;\n            yDiff = -6;\n            flipX = true;\n            rotation = 15 * (oneGradInRad);\n        }\n        else if (directionInDeg > (258.75 - halfStep) && directionInDeg < (258.75 + halfStep)) {\n            index = 4;\n            xDiff = 15;\n            yDiff = -2;\n            flipX = true;\n        }\n        else if (directionInDeg > (270 - halfStep) && directionInDeg < (270 + halfStep)) {\n            ////////////// LEFT /////////////\n            index = 4;\n            xDiff = 16;\n            yDiff = 0;\n            flipX = true;\n        }\n        else if (directionInDeg > (281.25 - halfStep) && directionInDeg < (281.25 + halfStep)) {\n            index = 4;\n            xDiff = 15;\n            yDiff = 2;\n            flipX = true;\n        }\n        else if (directionInDeg > (292.5 - halfStep) && directionInDeg < (292.5 + halfStep)) {\n            index = 3;\n            xDiff = 11;\n            yDiff = 4;\n            flipX = true;\n        }\n        else if (directionInDeg > (303.75 - halfStep) && directionInDeg < (303.75 + halfStep)) {\n            index = 3;\n            xDiff = 11;\n            yDiff = 4;\n            flipX = true;\n        }\n        else if (directionInDeg > (315 - halfStep) && directionInDeg < (315 + halfStep)) {\n            index = 2;\n            xDiff = 8;\n            yDiff = 7;\n            flipX = true;\n        }\n        else if (directionInDeg > (326.25 - halfStep) && directionInDeg < (326.25 + halfStep)) {\n            index = 2;\n            xDiff = 7;\n            yDiff = 8;\n            flipX = true;\n        }\n        else if (directionInDeg > (337.5 - halfStep) && directionInDeg < (337.5 + halfStep)) {\n            index = 1;\n            xDiff = 4;\n            yDiff = 10;\n            flipX = true;\n        }\n        else if (directionInDeg > (348.75 - halfStep) && directionInDeg < (348.75 + halfStep)) {\n            index = 1;\n            xDiff = 3;\n            yDiff = 12;\n            flipX = true;\n        }\n        return {\n            name: 'trail_' + index,\n            x: x + xDiff,\n            y: y + yDiff,\n            flipX: flipX,\n            rotation: rotation\n        };\n    };\n    BoatTrail.prototype.update = function (time, delta) {\n        if (this.player.speed <= 0) {\n            this.setVisible(false);\n            return;\n        }\n        if (this.visible === false) {\n            this.setVisible(true);\n        }\n        var tDiff = delta / 1000;\n        // взять нужный спрайт, подставить в отображение\n        var config = this.getTailConfig();\n        // обновляем отображаемый фрейм спрайта\n        // this.setFrame(config.frame);\n        this.x = config.x;\n        this.y = config.y;\n        // this.setFrame('boat_trail_5');\n        // this.setBodySize(frame.width, frame.height);\n        this.flipX = config.flipX || false;\n        this.rotation = config.rotation;\n        this.setDepth(this.player.depth + 1);\n        this.anims.play(config.name, true);\n        //\n        // // взять нужный спрайт, подставить в отображение\n        // let config = this.getPlayerSpriteByDirection(this, this.direction);\n        // // обновляем отображаемый фрейм спрайта\n        // let frame = this.setFrame(config.name);\n        // this.setBodySize(frame.width, frame.height);\n        //\n        // this.flipX = config.flipX || false;\n    };\n    // private updateVelocities() {\n    //     let directionInRad = this.direction * Math.PI / 180;\n    //     this.setVelocityX(this.speed * Math.sin(directionInRad));\n    //     this.setVelocityY(-1 * this.speed * Math.cos(directionInRad));\n    // }\n    BoatTrail.prototype.createTrailAnimations = function () {\n        var frameRate = 6;\n        this.scene.anims.create({ key: 'trail_0',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_0' },\n                { key: 'boat_trail', frame: 'boat_trail_1' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_1',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_2' },\n                { key: 'boat_trail', frame: 'boat_trail_3' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_2',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_4' },\n                { key: 'boat_trail', frame: 'boat_trail_5' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_3',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_6' },\n                { key: 'boat_trail', frame: 'boat_trail_7' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_4',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_8' },\n                { key: 'boat_trail', frame: 'boat_trail_9' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_5',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_10' },\n                { key: 'boat_trail', frame: 'boat_trail_11' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_6',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_12' },\n                { key: 'boat_trail', frame: 'boat_trail_13' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_7',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_14' },\n                { key: 'boat_trail', frame: 'boat_trail_15' },\n            ],\n            frameRate: frameRate\n        });\n        this.scene.anims.create({ key: 'trail_8',\n            frames: [\n                { key: 'boat_trail', frame: 'boat_trail_16' },\n                { key: 'boat_trail', frame: 'boat_trail_17' },\n            ],\n            frameRate: frameRate\n        });\n    };\n    return BoatTrail;\n}(Phaser.Physics.Arcade.Sprite));\nexports.BoatTrail = BoatTrail;\n\n\n//# sourceURL=webpack:///./src/Components/BoatTrail.ts?");

/***/ }),

/***/ "./src/Components/Corridor.ts":
/*!************************************!*\
  !*** ./src/Components/Corridor.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Corridor = /** @class */ (function () {\n    function Corridor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    return Corridor;\n}());\nexports.default = Corridor;\n\n\n//# sourceURL=webpack:///./src/Components/Corridor.ts?");

/***/ }),

/***/ "./src/Components/GameMenuButton.ts":
/*!******************************************!*\
  !*** ./src/Components/GameMenuButton.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar GameMenuButton = /** @class */ (function (_super) {\n    __extends(GameMenuButton, _super);\n    function GameMenuButton(scene, x, y, width, height, text) {\n        var _this = _super.call(this, scene, x, y) || this;\n        _this.defaultBgColor = 0xFFFF99;\n        _this.hoverBgColor = 0x99FFFF;\n        _this.defaultTextColor = '#fff';\n        _this.hoverTextColor = '#0ff';\n        _this.activeTextColor = '#ff0';\n        _this.buttonBg = scene.add.rectangle(0, 0, width, height, _this.defaultBgColor)\n            .setStrokeStyle(5, 0x9FF);\n        _this.buttonText = scene.add.text(0, 0, text)\n            .setColor('#000000')\n            .setFontSize(12)\n            .setFontStyle('bold');\n        // А теперь отцентруем текст на кнопке, с учётом его получившейся ширины\n        var textCenter = _this.buttonText.getCenter();\n        _this.buttonText.setX(Math.round(-textCenter.x));\n        _this.buttonText.setY(Math.round(-textCenter.y));\n        _this.add([_this.buttonBg, _this.buttonText])\n            .setSize(width, height)\n            .setInteractive({ useHandCursor: true });\n        _this.on('pointerover', function () { return _this.buttonHoverState(); })\n            .on('pointerout', function () { return _this.buttonRestState(); });\n        scene.add.existing(_this);\n        return _this;\n    }\n    GameMenuButton.prototype.buttonHoverState = function () {\n        this.buttonBg.setFillStyle(this.hoverBgColor);\n    };\n    GameMenuButton.prototype.buttonRestState = function () {\n        this.buttonBg.setFillStyle(this.defaultBgColor);\n    };\n    return GameMenuButton;\n}(Phaser.GameObjects.Container));\nexports.default = GameMenuButton;\n\n\n//# sourceURL=webpack:///./src/Components/GameMenuButton.ts?");

/***/ }),

/***/ "./src/Components/InGameSettingsButton.ts":
/*!************************************************!*\
  !*** ./src/Components/InGameSettingsButton.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar InGameSettingsButton = /** @class */ (function (_super) {\n    __extends(InGameSettingsButton, _super);\n    function InGameSettingsButton(scene, x, y, width, height) {\n        var _this = _super.call(this, scene, x, y) || this;\n        _this.defaultBgColor = 0xFFFF99;\n        _this.hoverBgColor = 0x99FFFF;\n        _this.buttonBg = scene.add.rectangle(0, 0, width, height, _this.defaultBgColor)\n            .setStrokeStyle(1, 0x000);\n        var buttonIcon = scene.add.image(0, 0, 'settingsIcon');\n        _this.add([_this.buttonBg, buttonIcon])\n            .setSize(width, height)\n            .setInteractive({ useHandCursor: true });\n        _this.on('pointerover', function () { return _this.buttonHoverState(); })\n            .on('pointerout', function () { return _this.buttonRestState(); });\n        scene.add.existing(_this);\n        return _this;\n    }\n    InGameSettingsButton.prototype.buttonHoverState = function () {\n        this.buttonBg.setFillStyle(this.hoverBgColor);\n    };\n    InGameSettingsButton.prototype.buttonRestState = function () {\n        this.buttonBg.setFillStyle(this.defaultBgColor);\n    };\n    return InGameSettingsButton;\n}(Phaser.GameObjects.Container));\nexports.default = InGameSettingsButton;\n\n\n//# sourceURL=webpack:///./src/Components/InGameSettingsButton.ts?");

/***/ }),

/***/ "./src/Components/NitroIndicatorOnPlayer.ts":
/*!**************************************************!*\
  !*** ./src/Components/NitroIndicatorOnPlayer.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NitroIndicatorOnPlayer = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar NitroIndicatorOnPlayer = /** @class */ (function (_super) {\n    __extends(NitroIndicatorOnPlayer, _super);\n    function NitroIndicatorOnPlayer(scene, player) {\n        var _this = _super.call(this, scene, player.x, player.y) || this;\n        _this.RADIUS = 25;\n        _this.player = player;\n        _this.indicator = scene.add.graphics();\n        _this.setDepth(_this.player.depth + 1);\n        _this.scene.add.existing(_this);\n        return _this;\n    }\n    NitroIndicatorOnPlayer.prototype.update = function (time, delta) {\n        this.indicator.clear();\n        if (!this.player.isNitroActive) {\n            this.setVisible(false);\n            return;\n        }\n        if (this.visible === false) {\n            this.setVisible(true);\n        }\n        var nitroDuration = this.player.NITRO_DURATION_IN_SEC * 1000;\n        var nitroTimeLeft = nitroDuration - (time - this.player.nitroActivatedTime);\n        // calc arc angle to draw\n        var percentTimeLeft = (nitroTimeLeft / nitroDuration);\n        var indicatorArcEndInDeg = 360 * percentTimeLeft;\n        if (nitroTimeLeft > 0) {\n            this.indicator.lineStyle(3, 0xff3300, 0.8);\n            this.indicator.setPosition(this.player.x, this.player.y);\n            this.indicator.beginPath()\n                .arc(0, 0, this.RADIUS, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(indicatorArcEndInDeg), false);\n            this.indicator.strokePath();\n        }\n    };\n    return NitroIndicatorOnPlayer;\n}(Phaser.GameObjects.Container));\nexports.NitroIndicatorOnPlayer = NitroIndicatorOnPlayer;\n\n\n//# sourceURL=webpack:///./src/Components/NitroIndicatorOnPlayer.ts?");

/***/ }),

/***/ "./src/Components/Player.ts":
/*!**********************************!*\
  !*** ./src/Components/Player.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Player = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar Player = /** @class */ (function (_super) {\n    __extends(Player, _super);\n    function Player(scene, x, y, textureName) {\n        if (textureName === void 0) { textureName = 'red_boat'; }\n        var _this = _super.call(this, scene, x, y, textureName) || this;\n        _this.playerSpriteRotateSize = 11.25; // 11.25 градусов на спрайт\n        _this.direction = 0;\n        _this.speed = 0;\n        _this.controlsHold = {\n            left: false,\n            right: false,\n            up: false,\n            down: false,\n            nitro: false\n        };\n        _this.nitroCount = 3;\n        _this.isNitroActive = false;\n        _this.nitroActivatedTime = 0;\n        _this.SPEED_LIMIT = 150;\n        _this.SPEED_LIMIT_ON_NITRO = 300;\n        _this.NITRO_DURATION_IN_SEC = 3;\n        _this.BACKWARD_SPEED_LIMIT = -20;\n        _this.ACCELERATION = 60; // m/sec^2\n        _this.DECELERATION = 80; // m/sec^2\n        _this.ROTATE_SPEED = 90; // Degrees per second\n        // add self to scene. And now it will be visible\n        _this.scene.add.existing(_this);\n        // and add to phisics, to get collide calculations\n        _this.scene.physics.add.existing(_this);\n        return _this;\n    }\n    Player.prototype.getPlayerSpriteByDirection = function (player, directionInDeg) {\n        var halfStep = this.playerSpriteRotateSize / 2;\n        var index = Math.round(directionInDeg / this.playerSpriteRotateSize);\n        // sprite indexes starts from 0 (on 0 degrees) to 16 (on 180 degrees).\n        // After 180 will be indexed from 16 to 0 and mirrored\n        // check rotate through 360 degrees\n        if ((directionInDeg > (360 - halfStep)) || directionInDeg < halfStep) {\n            index = 0;\n        }\n        var num = index;\n        if (index > 16) {\n            num = 32 - index;\n            return { name: 'red_boat_' + num, flipX: true };\n        }\n        return { name: 'red_boat_' + num, flipX: false };\n    };\n    ;\n    Player.prototype.holdLeft = function () {\n        this.controlsHold.left = true;\n    };\n    Player.prototype.holdRight = function () {\n        this.controlsHold.right = true;\n    };\n    Player.prototype.holdUp = function () {\n        this.controlsHold.up = true;\n    };\n    Player.prototype.holdDown = function () {\n        this.controlsHold.down = true;\n    };\n    Player.prototype.releaseLeft = function () {\n        this.controlsHold.left = false;\n    };\n    Player.prototype.releaseRight = function () {\n        this.controlsHold.right = false;\n    };\n    Player.prototype.releaseUp = function () {\n        this.controlsHold.up = false;\n    };\n    Player.prototype.releaseDown = function () {\n        this.controlsHold.down = false;\n    };\n    Player.prototype.holdNitro = function () {\n        this.controlsHold.nitro = true;\n    };\n    Player.prototype.releaseNitro = function () {\n        this.controlsHold.nitro = false;\n    };\n    Player.prototype.update = function (time, delta) {\n        var tDiff = delta / 1000;\n        var cursors = this.scene.input.keyboard.createCursorKeys();\n        if (this.speed < 0) {\n            // rear move rotate logic\n            if (cursors.left.isDown || this.controlsHold.left) {\n                this.direction += (this.ROTATE_SPEED * tDiff);\n                if (this.direction > 360) {\n                    this.direction = this.direction - 360;\n                }\n            }\n            else if (cursors.right.isDown || this.controlsHold.right) {\n                this.direction -= (this.ROTATE_SPEED * tDiff);\n                if (this.direction < 0) {\n                    this.direction = 360 - (this.direction);\n                }\n            }\n        }\n        else {\n            // front move rotate logic\n            if (cursors.left.isDown || this.controlsHold.left) {\n                this.direction -= (this.ROTATE_SPEED * tDiff);\n                if (this.direction < 0) {\n                    this.direction = 360 - (this.direction);\n                }\n            }\n            else if (cursors.right.isDown || this.controlsHold.right) {\n                this.direction += (this.ROTATE_SPEED * tDiff);\n                if (this.direction > 360) {\n                    this.direction = this.direction - 360;\n                }\n            }\n        }\n        if (cursors.up.isDown || this.controlsHold.up) {\n            this.speed += (this.ACCELERATION * tDiff);\n            if (this.speed > this.SPEED_LIMIT) {\n                this.speed = this.SPEED_LIMIT;\n            }\n        }\n        else if (cursors.down.isDown) {\n            this.speed -= (this.DECELERATION * tDiff);\n            if (this.speed < this.BACKWARD_SPEED_LIMIT) {\n                this.speed = this.BACKWARD_SPEED_LIMIT;\n            }\n        }\n        if (cursors.space.isDown || this.controlsHold.down) {\n            if (this.speed > 0) {\n                this.speed -= (this.DECELERATION * tDiff);\n                if (this.speed < 0) {\n                    this.speed = 0;\n                }\n            }\n            else if (this.speed < 0) {\n                this.speed += (this.DECELERATION * tDiff);\n                if (this.speed > 0) {\n                    this.speed = 0;\n                }\n            }\n        }\n        if ((cursors.shift.isDown || this.controlsHold.nitro) && !this.isNitroActive && this.nitroCount > 0) {\n            //////////////// NITRO ACTIVATED!\n            this.isNitroActive = true;\n            this.nitroActivatedTime = time;\n            this.nitroCount--;\n            console.log('is nitro active: ', this.isNitroActive);\n            console.log('nitros left: ', this.nitroCount);\n        }\n        // IF NITRO IS ACTIVE - MAX SPEEEEEED!!!\n        if (this.isNitroActive) {\n            var nitroTime = (time - this.nitroActivatedTime) / 1000;\n            if (nitroTime < this.NITRO_DURATION_IN_SEC) {\n                this.speed = this.SPEED_LIMIT_ON_NITRO;\n            }\n            else {\n                this.isNitroActive = false;\n                this.nitroActivatedTime = 0;\n                this.speed = this.SPEED_LIMIT;\n            }\n        }\n        // OK, digits are sets. Now calc velocities of player with digits\n        this.updateVelocities();\n        // look select sprite by direction\n        var config = this.getPlayerSpriteByDirection(this, this.direction);\n        this.setFrameData(config.name);\n        this.flipX = config.flipX || false;\n    };\n    Player.prototype.setFrameData = function (frameName) {\n        var frame = this.setFrame(frameName);\n        this.setBodySize(frame.width, frame.height);\n    };\n    Player.prototype.updateVelocities = function () {\n        var directionInRad = this.direction * Math.PI / 180;\n        this.setVelocityX(this.speed * Math.sin(directionInRad));\n        this.setVelocityY(-1 * this.speed * Math.cos(directionInRad));\n    };\n    Player.prototype.getDirection = function () {\n        return this.direction;\n    };\n    Player.prototype.setDirection = function (direction) {\n        this.direction = direction;\n    };\n    Player.prototype.getSpeed = function () {\n        return this.speed;\n    };\n    Player.prototype.setSpeed = function (speed) {\n        this.speed = speed;\n    };\n    Player.prototype.getNitroCount = function () {\n        return this.nitroCount;\n    };\n    Player.prototype.addNitro = function (count) {\n        if (count === void 0) { count = 1; }\n        this.nitroCount += count;\n    };\n    return Player;\n}(Phaser.Physics.Arcade.Sprite));\nexports.Player = Player;\n\n\n//# sourceURL=webpack:///./src/Components/Player.ts?");

/***/ }),

/***/ "./src/Components/Popup/PopupManager.ts":
/*!**********************************************!*\
  !*** ./src/Components/Popup/PopupManager.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PopupWindow_1 = __webpack_require__(/*! ./PopupWindow */ \"./src/Components/Popup/PopupWindow.ts\");\nvar PopupManager = /** @class */ (function () {\n    function PopupManager() {\n    }\n    PopupManager.createWindow = function (scene, popup) {\n        // ЕСЛИ ПЕРЕДАННЫЙ ПОПАП ДОЛЖЕН БЫТЬ ОТКРЫТ ТОЛЬКО ОДИН РАЗ И УЖЕ ОТКРЫТ - ВЫХОДИМ\n        if (popup.ONCE_AT_TIME === true && this.openedPopups[popup.POPUP_ID]) {\n            return;\n        }\n        if (popup.SET_PAUSE === true) {\n            this.isPausedGame = true;\n        }\n        var x = (scene.gameWidth / 2) - (popup.WIDTH / 2);\n        var y = scene.gameHeight / 2 - popup.HEIGHT / 2;\n        var windowID = 'window' + this.popupCount++;\n        var win = scene.add.zone(x, y, popup.WIDTH, popup.HEIGHT)\n            .setInteractive({ useHandCursor: true })\n            .setOrigin(0);\n        var demo = new PopupWindow_1.default(scene, popup, windowID, win);\n        // TODO: разобраться почему DRAG'N'DROP не работает\n        scene.input.setDraggable(win);\n        win.on('drag', function (pointer, dragX, dragY) {\n            win.x = dragX;\n            win.y = dragY;\n            console.log('drag');\n            demo.refresh();\n        });\n        scene.scene.add(windowID, demo, true);\n        // чтобы потом суметь закрыть открытый попап, и проверить, может уже открывали\n        this.openedPopups[popup.POPUP_ID] = windowID;\n        this.openedHandles[windowID] = popup.POPUP_ID;\n        if (this.isPausedGame) {\n            scene.scene.pause();\n        }\n    };\n    PopupManager.closeWindow = function (scene, windowId) {\n        var popupId = this.openedHandles[windowId];\n        // reduce, чтобы собрать новый список, без переданного windowId\n        this.openedHandles = Object.entries(this.openedHandles).reduce(function (newObj, _a) {\n            var _b;\n            var key = _a[0], val = _a[1];\n            if (key === windowId) {\n                return newObj;\n            }\n            return __assign(__assign({}, newObj), (_b = {}, _b[key] = val, _b));\n        }, {});\n        // reduce, чтобы собрать новый список, без убранного ранее popupId\n        this.openedPopups = Object.entries(this.openedPopups).reduce(function (newObj, _a) {\n            var _b;\n            var key = _a[0], val = _a[1];\n            if (key === popupId) {\n                return newObj;\n            }\n            return __assign(__assign({}, newObj), (_b = {}, _b[key] = val, _b));\n        }, {});\n        // если не осталось блокирующих попапов - снимаем паузу\n        if (Object.entries(this.openedPopups).length === 0) {\n            scene.scene.resume();\n        }\n    };\n    PopupManager.popupCount = 0;\n    PopupManager.openedPopups = {}; // PopupID->handle\n    PopupManager.openedHandles = {}; // handle->PopupID\n    PopupManager.isPausedGame = false; // если при открытии нужно заморозить игру\n    return PopupManager;\n}());\nexports.default = PopupManager;\n\n\n//# sourceURL=webpack:///./src/Components/Popup/PopupManager.ts?");

/***/ }),

/***/ "./src/Components/Popup/PopupWindow.ts":
/*!*********************************************!*\
  !*** ./src/Components/Popup/PopupWindow.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PopupManager_1 = __webpack_require__(/*! ./PopupManager */ \"./src/Components/Popup/PopupManager.ts\");\nvar SceneBase_1 = __webpack_require__(/*! ../../scenes/SceneBase */ \"./src/scenes/SceneBase.ts\");\nvar PopupWindow = /** @class */ (function (_super) {\n    __extends(PopupWindow, _super);\n    function PopupWindow(parentScene, popup, handle, parent) {\n        var _this = this;\n        var sceneConfig = {\n            active: false,\n            visible: false,\n            key: handle,\n        };\n        _this = _super.call(this, sceneConfig) || this;\n        _this.parentScene = parentScene;\n        _this.popup = popup;\n        _this.handle = handle;\n        _this.parent = parent;\n        _this.WIDTH = popup.WIDTH;\n        _this.HEIGHT = popup.HEIGHT;\n        return _this;\n    }\n    PopupWindow.prototype.create = function () {\n        var _this = this;\n        var bMargin = 5; // border margin\n        var bWidth = 2; // border width\n        // фон и рамка окна\n        this.add.rectangle(0, 0, this.WIDTH, this.HEIGHT, 0xcccccc)\n            .setOrigin(0);\n        this.add.rectangle(bMargin, bMargin, this.WIDTH - (2 * bMargin), this.HEIGHT - (2 * bMargin), 0x000000)\n            .setOrigin(0);\n        this.add.rectangle(bMargin + bWidth, bMargin + bWidth, this.WIDTH - (2 * (bMargin + bWidth)), this.HEIGHT - (2 * (bMargin + bWidth)), 0xcccccc)\n            .setOrigin(0);\n        // кнопка закрытия окна\n        this.add.rectangle(this.WIDTH - 18, 4, 14, 14, 0xcccccc)\n            .setOrigin(0)\n            .setInteractive({ useHandCursor: true })\n            .on('pointerup', function () {\n            _this.scene.stop(_this.handle);\n            PopupManager_1.default.closeWindow(_this.parentScene, _this.handle);\n        });\n        this.add.line(this.WIDTH - 16, 4, 0, 0, 12, 12, 0x000000)\n            .setOrigin(0);\n        this.add.line(this.WIDTH - 16, 4, 0, 12, 12, 0, 0x000000)\n            .setOrigin(0);\n        // содержимое окна\n        this.popup.drawPopupContent(this);\n        this.cameras.main.setViewport(this.parent.x, this.parent.y, this.WIDTH, this.HEIGHT);\n        // если из попапа выбросили событие с требованием закрыть попап\n        this.events.on('CLOSE_POPUP', function () {\n            _this.scene.stop(_this.handle);\n            PopupManager_1.default.closeWindow(_this.parentScene, _this.handle);\n        });\n    };\n    PopupWindow.prototype.update = function () {\n    };\n    PopupWindow.prototype.refresh = function () {\n        this.cameras.main.setPosition(this.parent.x, this.parent.y);\n        this.scene.bringToTop();\n    };\n    return PopupWindow;\n}(SceneBase_1.SceneBase));\nexports.default = PopupWindow;\n\n\n//# sourceURL=webpack:///./src/Components/Popup/PopupWindow.ts?");

/***/ }),

/***/ "./src/Components/Popup/PopupWindowType.ts":
/*!*************************************************!*\
  !*** ./src/Components/Popup/PopupWindowType.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PopupWindowType = /** @class */ (function () {\n    function PopupWindowType() {\n        this.WIDTH = 250;\n        this.HEIGHT = 60;\n        this.ONCE_AT_TIME = true;\n        this.POPUP_ID = 'PopupID';\n        this.SET_PAUSE = true;\n    }\n    PopupWindowType.prototype.drawPopupContent = function (scene) {\n        // Отрисовать содержимое попапа в его сцене\n        scene.add.text(20, 20, 'Ой! Базовый PopupWindowType!')\n            .setColor('black');\n    };\n    return PopupWindowType;\n}());\nexports.default = PopupWindowType;\n\n\n//# sourceURL=webpack:///./src/Components/Popup/PopupWindowType.ts?");

/***/ }),

/***/ "./src/Components/Popup/Popups/LevelCompletedPopup.ts":
/*!************************************************************!*\
  !*** ./src/Components/Popup/Popups/LevelCompletedPopup.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PopupWindowType_1 = __webpack_require__(/*! ../PopupWindowType */ \"./src/Components/Popup/PopupWindowType.ts\");\nvar LevelCompletedPopup = /** @class */ (function (_super) {\n    __extends(LevelCompletedPopup, _super);\n    function LevelCompletedPopup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.WIDTH = 350;\n        _this.HEIGHT = 250;\n        _this.ONCE_AT_TIME = true;\n        _this.POPUP_ID = 'LevelCompletedPopup';\n        return _this;\n    }\n    LevelCompletedPopup.prototype.drawPopupContent = function (scene) {\n        // Отрисовать содержимое попапа в его сцене\n        var headerStyle = { fontSize: '18px', fill: '#000', fontFamily: 'Arial, sans-serif' };\n        var textStyle = { fontSize: '12px', fill: '#000', fontFamily: 'Arial, sans-serif' };\n        scene.add.text(20, 35, 'Уровень пройден!')\n            .setStyle(headerStyle);\n        scene.add.text(20, 180, 'Начать следующий уровень')\n            .setColor('red')\n            .setBackgroundColor('white')\n            .setPadding(20, 10, 20, 10)\n            .setInteractive({ useHandCursor: true })\n            .on('pointerdown', function () {\n            scene.events.emit('CLOSE_POPUP');\n            scene.game.events.emit('GO_TO_NEXT_LEVEL');\n        });\n    };\n    return LevelCompletedPopup;\n}(PopupWindowType_1.default));\nexports.default = LevelCompletedPopup;\n\n\n//# sourceURL=webpack:///./src/Components/Popup/Popups/LevelCompletedPopup.ts?");

/***/ }),

/***/ "./src/Components/Popup/Popups/SettingsPopup.ts":
/*!******************************************************!*\
  !*** ./src/Components/Popup/Popups/SettingsPopup.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PopupWindowType_1 = __webpack_require__(/*! ../PopupWindowType */ \"./src/Components/Popup/PopupWindowType.ts\");\nvar SettingsPopup = /** @class */ (function (_super) {\n    __extends(SettingsPopup, _super);\n    function SettingsPopup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.WIDTH = 250;\n        _this.HEIGHT = 350;\n        _this.ONCE_AT_TIME = true;\n        _this.POPUP_ID = 'SettingsPopup';\n        return _this;\n    }\n    SettingsPopup.prototype.drawPopupContent = function (scene) {\n        // Отрисовать содержимое попапа в его сцене\n        var headerStyle = { fontSize: '18px', fill: '#000', fontFamily: 'Arial, sans-serif' };\n        var textStyle = { fontSize: '12px', fill: '#000', fontFamily: 'Arial, sans-serif' };\n        scene.add.text(20, 35, 'Управление')\n            .setStyle(headerStyle);\n        scene.add.text(20, 60, 'Вверх - ускорение').setStyle(textStyle);\n        scene.add.text(20, 77, 'Вниз - движение назад').setStyle(textStyle);\n        scene.add.text(20, 94, 'Право/Лево - поворот').setStyle(textStyle);\n        scene.add.text(20, 110, 'Пробел - торможение').setStyle(textStyle);\n        scene.add.text(20, 127, 'Shift - НИТРО!').setStyle(textStyle);\n        scene.add.text(20, 280, 'Выйти в главное меню')\n            .setColor('red')\n            .setInteractive({ useHandCursor: true })\n            .on('pointerdown', function () {\n            var r = confirm('Are you sure to exit in main menu?');\n            if (r) {\n                scene.events.emit('CLOSE_POPUP');\n                scene.game.events.emit('GO_TO_MAIN_MENU');\n            }\n        });\n    };\n    return SettingsPopup;\n}(PopupWindowType_1.default));\nexports.default = SettingsPopup;\n\n\n//# sourceURL=webpack:///./src/Components/Popup/Popups/SettingsPopup.ts?");

/***/ }),

/***/ "./src/Components/RedCarPlayer.ts":
/*!****************************************!*\
  !*** ./src/Components/RedCarPlayer.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RedCarPlayer = void 0;\nvar Player_1 = __webpack_require__(/*! ./Player */ \"./src/Components/Player.ts\");\nvar RedCarPlayer = /** @class */ (function (_super) {\n    __extends(RedCarPlayer, _super);\n    function RedCarPlayer(scene, x, y, textureName) {\n        if (textureName === void 0) { textureName = 'red_car'; }\n        var _this = _super.call(this, scene, x, y, textureName) || this;\n        _this.playerSpriteRotateSize = 22.5; // градусов дуги на спрайт\n        _this.direction = 0;\n        _this.speed = 0;\n        _this.controlsHold = {\n            left: false,\n            right: false,\n            up: false,\n            down: false,\n            nitro: false\n        };\n        _this.nitroCount = 3;\n        _this.isNitroActive = false;\n        _this.nitroActivatedTime = 0;\n        _this.SPEED_LIMIT = 150;\n        _this.SPEED_LIMIT_ON_NITRO = 300;\n        _this.NITRO_DURATION_IN_SEC = 3;\n        _this.BACKWARD_SPEED_LIMIT = -20;\n        _this.ACCELERATION = 60; // m/sec^2\n        _this.DECELERATION = 80; // m/sec^2\n        _this.ROTATE_SPEED = 90; // Degrees per second\n        return _this;\n    }\n    RedCarPlayer.prototype.getPlayerSpriteByDirection = function (player, directionInDeg) {\n        var halfStep = this.playerSpriteRotateSize / 2;\n        // sprite list starts from direction of 225 degrees. Lets correct index to 0 or 360 degrees = index 0\n        var index = Math.round(directionInDeg / this.playerSpriteRotateSize) + 6;\n        // check rotate through 360 degrees\n        if ((directionInDeg > (360 - halfStep)) || directionInDeg < halfStep) {\n            index = 6;\n        }\n        if (index > 15) {\n            index = index - 16;\n        }\n        return { name: 'red_car_' + index, flipX: false };\n    };\n    ;\n    RedCarPlayer.prototype.setFrameData = function (frameName) {\n        var frame = this.setFrame(frameName);\n        this.setBodySize(frame.width, frame.height);\n        this.setScale(0.7);\n    };\n    return RedCarPlayer;\n}(Player_1.Player));\nexports.RedCarPlayer = RedCarPlayer;\n\n\n//# sourceURL=webpack:///./src/Components/RedCarPlayer.ts?");

/***/ }),

/***/ "./src/Components/Room.ts":
/*!********************************!*\
  !*** ./src/Components/Room.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Room = /** @class */ (function () {\n    function Room(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    return Room;\n}());\nexports.default = Room;\n\n\n//# sourceURL=webpack:///./src/Components/Room.ts?");

/***/ }),

/***/ "./src/Components/TextButton.ts":
/*!**************************************!*\
  !*** ./src/Components/TextButton.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar TextButton = /** @class */ (function (_super) {\n    __extends(TextButton, _super);\n    function TextButton(scene, x, y, text, style) {\n        var _this = _super.call(this, scene, x, y, text, style) || this;\n        _this.defaultTextColor = '#fff';\n        _this.hoverTextColor = '#0ff';\n        _this.activeTextColor = '#ff0';\n        _this.setFontSize(10);\n        _this.setShadow(0, 0, 'black', 5);\n        _this.setStyle({ fill: _this.defaultTextColor });\n        _this.setInteractive({ useHandCursor: true })\n            .on('pointerover', function () { return _this.buttonHoverState(); })\n            .on('pointerout', function () { return _this.buttonRestState(); })\n            .on('pointerdown', function () { return _this.buttonActiveState(); })\n            .on('pointerup', function () { return _this.buttonHoverState(); });\n        return _this;\n    }\n    TextButton.prototype.buttonHoverState = function () {\n        this.setStyle({ fill: this.hoverTextColor });\n    };\n    TextButton.prototype.buttonRestState = function () {\n        this.setStyle({ fill: this.defaultTextColor });\n    };\n    TextButton.prototype.buttonActiveState = function () {\n        this.setStyle({ fill: this.activeTextColor });\n    };\n    return TextButton;\n}(Phaser.GameObjects.Text));\nexports.default = TextButton;\n\n\n//# sourceURL=webpack:///./src/Components/TextButton.ts?");

/***/ }),

/***/ "./src/Components/Tree.ts":
/*!********************************!*\
  !*** ./src/Components/Tree.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Room_1 = __webpack_require__(/*! ./Room */ \"./src/Components/Room.ts\");\nvar Tree = /** @class */ (function () {\n    function Tree(width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = 0;\n        this.y = 0;\n    }\n    /**\n     * Берёт из узла или собственную комнату или одну из комнат его дочерних узлов\n     */\n    Tree.prototype.getRoom = function () {\n        if (this.room instanceof Room_1.default) {\n            return this.room;\n        }\n        var leftRoom, rightRoom;\n        if (this.left instanceof Tree) {\n            leftRoom = this.left.getRoom();\n        }\n        if (this.left instanceof Tree) {\n            rightRoom = this.right.getRoom();\n        }\n        if (leftRoom === null && rightRoom === null) {\n            return null;\n        }\n        if (leftRoom !== null || rightRoom !== null) {\n            return leftRoom === null ? rightRoom : leftRoom;\n        }\n        // если есть обе комнаты, всегда возвращаем левую\n        return leftRoom;\n    };\n    return Tree;\n}());\nexports.default = Tree;\n\n\n//# sourceURL=webpack:///./src/Components/Tree.ts?");

/***/ }),

/***/ "./src/Config.ts":
/*!***********************!*\
  !*** ./src/Config.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Config = void 0;\nvar Config = /** @class */ (function () {\n    function Config() {\n    }\n    // game dimensions\n    Config.GAME_WIDTH = 800;\n    Config.GAME_HEIGHT = 600;\n    return Config;\n}());\nexports.Config = Config;\n\n\n//# sourceURL=webpack:///./src/Config.ts?");

/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MyGame = void 0;\nvar HelloScene_1 = __webpack_require__(/*! ./scenes/HelloScene */ \"./src/scenes/HelloScene.ts\");\nvar GameScene_1 = __webpack_require__(/*! ./scenes/GameScene */ \"./src/scenes/GameScene.ts\");\nvar GeneratorScene_1 = __webpack_require__(/*! ./scenes/GeneratorScene */ \"./src/scenes/GeneratorScene.ts\");\nvar Center = Phaser.Scale.Center;\nvar Boot_1 = __webpack_require__(/*! ./scenes/Boot */ \"./src/scenes/Boot.ts\");\nvar Preloader_1 = __webpack_require__(/*! ./scenes/Preloader */ \"./src/scenes/Preloader.ts\");\nvar Config_1 = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\nvar MyGame = /** @class */ (function (_super) {\n    __extends(MyGame, _super);\n    // --------------------------------------------------------------------\n    function MyGame() {\n        var _this = this;\n        console.log(\"MyGame\");\n        // default renderer\n        var renderer = Phaser.AUTO;\n        // init game\n        _this = _super.call(this, {\n            type: renderer,\n            parent: \"game\",\n            width: Config_1.Config.GAME_WIDTH,\n            height: Config_1.Config.GAME_HEIGHT,\n            scale: {\n                autoCenter: Center.CENTER_HORIZONTALLY\n            },\n            title: \"Boat Game Prototype\",\n            backgroundColor: '#000000',\n            physics: {\n                default: 'arcade',\n                arcade: {\n                    debug: false,\n                },\n            },\n            render: {\n                antialias: false,\n                antialiasGL: false,\n            }\n        }) || this;\n        // states\n        _this.scene.add(\"Boot\", Boot_1.Boot);\n        _this.scene.add(\"Preloader\", Preloader_1.Preloader);\n        _this.scene.add(\"Hello\", HelloScene_1.HelloScene);\n        _this.scene.add(\"Game\", GameScene_1.GameScene);\n        _this.scene.add(\"Generator\", GeneratorScene_1.GeneratorScene);\n        // start\n        _this.scene.start(\"Boot\");\n        return _this;\n    }\n    return MyGame;\n}(Phaser.Game));\nexports.MyGame = MyGame;\n\n\n//# sourceURL=webpack:///./src/Game.ts?");

/***/ }),

/***/ "./src/lib/BSPMazeGenerator.ts":
/*!*************************************!*\
  !*** ./src/lib/BSPMazeGenerator.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Tree_1 = __webpack_require__(/*! ../Components/Tree */ \"./src/Components/Tree.ts\");\nvar Room_1 = __webpack_require__(/*! ../Components/Room */ \"./src/Components/Room.ts\");\nvar Corridor_1 = __webpack_require__(/*! ../Components/Corridor */ \"./src/Components/Corridor.ts\");\nvar KeyGenerator_1 = __webpack_require__(/*! ./KeyGenerator */ \"./src/lib/KeyGenerator.ts\");\nvar CellularAutomate_1 = __webpack_require__(/*! ./CellularAutomate */ \"./src/lib/CellularAutomate.ts\");\nvar MathUtils_1 = __webpack_require__(/*! ./MathUtils */ \"./src/lib/MathUtils.ts\");\nvar BSPMazeGenerator = /** @class */ (function () {\n    function BSPMazeGenerator() {\n        this.zones = [];\n        this.rooms = [];\n        this.corridors = [];\n        this.debugMarks = [];\n        this.MAX = 50; // максимальный размер зоны - если больше, то можно делить\n        // минимальный размер комнаты удобно делать больше 50%. Тогда при соединении\n        // всегда рисуем коридор посередине и попадаем куда надо :)\n        this.MIN_ROOM_SIZE = 70; // в процентах от размера зоны\n        this.MIN_ROOM_MARGIN = 5; // комната не должна быть к краю зоны ближе чем это значение\n        this.CORRIDOR_WIDTH = 4;\n        this.SPLIT_FROM = 20; // ограничение по разделению на зоны, не ближе чем 30% от одной стены\n        this.SPLIT_TO = 80; // ограничение по разделению на зоны, не ближе чем 70% от другой стены\n    }\n    BSPMazeGenerator.prototype.getZones = function () {\n        return this.zones;\n    };\n    BSPMazeGenerator.prototype.getRooms = function () {\n        return this.rooms;\n    };\n    BSPMazeGenerator.prototype.getCorridors = function () {\n        return this.corridors;\n    };\n    BSPMazeGenerator.prototype.generateMap = function (mapWidth, mapHeight, smoothIterations) {\n        var startTree = new Tree_1.default(mapWidth, mapHeight);\n        startTree.x = 0;\n        startTree.y = 0;\n        startTree.id = 'T' + KeyGenerator_1.default.getNextKey();\n        this.zones.push(startTree);\n        // сгенерируем дерево\n        var tree = this.generate(startTree);\n        this.createRooms(tree);\n        // Построим карту с помощью клеточного автомата\n        this.cellularAutomate = new CellularAutomate_1.default(mapWidth, mapHeight, this.rooms, this.corridors);\n        this.cellularAutomate.initializeMap();\n        // если затребован фильтр для сглаживания границ - используем его\n        if (smoothIterations > 0) {\n            this.cellularAutomate.run(smoothIterations);\n        }\n        return this.cellularAutomate.getMap();\n    };\n    BSPMazeGenerator.prototype.getMap = function () {\n        return this.cellularAutomate.getMap();\n    };\n    /**\n     * Прогоняет по карте одну итерацию клеточного автомата\n     */\n    BSPMazeGenerator.prototype.runFilterIteration = function () {\n        this.cellularAutomate.run();\n    };\n    /**\n     * Отрисовывает карту в переданный объект graphics\n     * @param graphics\n     */\n    BSPMazeGenerator.prototype.renderMap = function (graphics) {\n        this.cellularAutomate.renderMap(graphics);\n    };\n    BSPMazeGenerator.prototype.getSplitSizes = function (size) {\n        var splitMin = size / 100 * this.SPLIT_FROM;\n        var splitMax = size / 100 * this.SPLIT_TO;\n        var point = MathUtils_1.default.getRandomIntegerBetween(splitMin, splitMax);\n        return [point, size - point];\n    };\n    BSPMazeGenerator.prototype.generate = function (tree) {\n        var _a, _b;\n        var splitType;\n        // если не делится, просто возвращаемся сразу\n        if (tree.width < this.MAX && tree.height < this.MAX) {\n            return tree;\n        }\n        if (tree.width > this.MAX && tree.height > this.MAX) {\n            // get random split type\n            var array = ['vertical', 'horizontal'];\n            splitType = array[Math.floor(Math.random() * array.length)];\n        }\n        else {\n            splitType = tree.width > this.MAX ? 'vertical' : 'horizontal';\n        }\n        var leftSize, rightSize;\n        var leftTree, rightTree;\n        if (splitType === 'vertical') {\n            if (tree.width > this.MAX) {\n                _a = this.getSplitSizes(tree.width), leftSize = _a[0], rightSize = _a[1];\n                leftTree = new Tree_1.default(leftSize, tree.height);\n                rightTree = new Tree_1.default(rightSize, tree.height);\n                leftTree.x = tree.x;\n                leftTree.y = tree.y;\n                rightTree.x = tree.x + leftSize;\n                rightTree.y = tree.y;\n            }\n        }\n        else {\n            if (tree.height > this.MAX) {\n                _b = this.getSplitSizes(tree.height), leftSize = _b[0], rightSize = _b[1];\n                leftTree = new Tree_1.default(tree.width, leftSize);\n                rightTree = new Tree_1.default(tree.width, rightSize);\n                leftTree.x = tree.x;\n                leftTree.y = tree.y;\n                rightTree.x = tree.x;\n                rightTree.y = tree.y + leftSize;\n            }\n        }\n        if (leftTree instanceof Tree_1.default) {\n            leftTree.id = 'T' + KeyGenerator_1.default.getNextKey();\n            this.zones.push(leftTree);\n            tree.left = this.generate(leftTree);\n        }\n        if (rightTree instanceof Tree_1.default) {\n            rightTree.id = 'T' + KeyGenerator_1.default.getNextKey();\n            this.zones.push(rightTree);\n            tree.right = this.generate(rightTree);\n        }\n        return tree;\n    };\n    // Создаём комнаты в зонах\n    BSPMazeGenerator.prototype.createRooms = function (tree) {\n        if (!(tree.left instanceof Tree_1.default && tree.right instanceof Tree_1.default)) {\n            // отрисуем \"комнату\" в зоне. Комнаты должны быть меньше от 10 до 30% чем ячейка\n            // минимальный размер комнаты - 60% от зоны\n            var minWidth = tree.width / 100 * this.MIN_ROOM_SIZE;\n            var minHeight = tree.height / 100 * this.MIN_ROOM_SIZE;\n            var roomOffsetX = MathUtils_1.default.getRandomIntegerBetween(this.MIN_ROOM_MARGIN, tree.width - minWidth);\n            var roomOffsetY = MathUtils_1.default.getRandomIntegerBetween(this.MIN_ROOM_MARGIN, tree.height - minHeight);\n            var roomWidth = MathUtils_1.default.getRandomIntegerBetween(minWidth, tree.width - roomOffsetX - this.MIN_ROOM_MARGIN);\n            var roomHeight = MathUtils_1.default.getRandomIntegerBetween(minHeight, tree.height - roomOffsetY - this.MIN_ROOM_MARGIN);\n            // создаём комнату с реальными x и y на холсте\n            var roomX = tree.x + roomOffsetX;\n            var roomY = tree.y + roomOffsetY;\n            tree.room = new Room_1.default(roomX, roomY, roomWidth, roomHeight);\n            tree.room.tree = tree;\n            tree.room.id = KeyGenerator_1.default.getNextKey('R');\n            this.rooms.push(tree.room);\n        }\n        if (tree.left instanceof Tree_1.default && tree.right instanceof Tree_1.default) {\n            this.createRooms(tree.left);\n            this.createRooms(tree.right);\n            var corridor = this.getCorridor(tree.left, tree.right);\n            if (corridor instanceof Corridor_1.default) {\n                this.corridors.push(corridor);\n            }\n        }\n    };\n    BSPMazeGenerator.prototype.getCorridor = function (treeNode1, treeNode2) {\n        var minCorridorSize = this.CORRIDOR_WIDTH;\n        var corridorId;\n        var corridorX, corridorY, corridorWidth, corridorHeight;\n        // Тип разделения - сравним координаты x и y у зон\n        if (treeNode1.x === treeNode2.x) {\n            // вертикальное разделение - коридор рисуем вертикально\n            var top_1, bottom = void 0;\n            if (treeNode1.y < treeNode2.y) {\n                top_1 = treeNode1;\n                bottom = treeNode2;\n            }\n            else {\n                top_1 = treeNode2;\n                bottom = treeNode1;\n            }\n            var topRoom = top_1.getRoom();\n            var bottomRoom = bottom.getRoom();\n            // вычисляем позицию и размеры коридора между комнатами\n            corridorWidth = minCorridorSize;\n            var topRoomBottomY = topRoom.y + topRoom.height;\n            var bottomRoomTopY = bottomRoom.y;\n            // смещение центра коридора по Y, чтобы попасть на обе комнаты\n            corridorHeight = Math.max(bottomRoomTopY, topRoomBottomY) - Math.min(bottomRoomTopY, topRoomBottomY);\n            corridorY = topRoom.y + topRoom.height + (corridorHeight / 2);\n            var topRoomCenterX = topRoom.x + topRoom.width / 2;\n            var bottomRoomCenterX = bottomRoom.x + bottomRoom.width / 2;\n            var centerDiffX = Math.abs(topRoomCenterX - bottomRoomCenterX);\n            corridorX = Math.min(topRoomCenterX, bottomRoomCenterX) + centerDiffX / 2;\n            corridorId = topRoom.id + bottomRoom.id;\n            var newCoord = this.checkAndUpdateCorridorCoords(corridorX, corridorWidth, topRoom.x, topRoom.width, bottomRoom.x, bottomRoom.width);\n            corridorX = newCoord.coord;\n            corridorWidth = newCoord.size;\n        }\n        else {\n            // горизонтальное разделение - коридор горизонтальный\n            var left = void 0, right = void 0;\n            if (treeNode1.x < treeNode2.x) {\n                left = treeNode1;\n                right = treeNode2;\n            }\n            else {\n                left = treeNode2;\n                right = treeNode1;\n            }\n            var leftRoom = left.getRoom();\n            var rightRoom = right.getRoom();\n            // вычисляем позицию и размеры коридора между комнатами\n            corridorHeight = minCorridorSize;\n            var leftRoomRightX = leftRoom.x + leftRoom.width;\n            var rightRoomLeftX = (rightRoom.x);\n            // смещение центра коридора по X, чтобы попасть на обе комнаты\n            corridorWidth = Math.max(rightRoomLeftX, leftRoomRightX) - Math.min(rightRoomLeftX, leftRoomRightX);\n            corridorX = leftRoom.x + leftRoom.width + (corridorWidth / 2);\n            var leftRoomCenterY = leftRoom.y + leftRoom.height / 2;\n            var rightRoomCenterY = rightRoom.y + rightRoom.height / 2;\n            var centerDiffY = Math.abs(leftRoomCenterY - rightRoomCenterY);\n            corridorY = Math.min(leftRoomCenterY, rightRoomCenterY) + centerDiffY / 2;\n            corridorId = leftRoom.id + rightRoom.id;\n            var newCoord = this.checkAndUpdateCorridorCoords(corridorY, corridorHeight, leftRoom.y, leftRoom.height, rightRoom.y, rightRoom.height);\n            corridorY = newCoord.coord;\n            corridorHeight = newCoord.size;\n        }\n        var c = new Corridor_1.default(Math.floor(corridorX - corridorWidth / 2), Math.floor(corridorY - corridorHeight / 2), Math.floor(corridorWidth), Math.floor(corridorHeight));\n        c.id = corridorId;\n        return c;\n    };\n    BSPMazeGenerator.prototype.checkAndUpdateCorridorCoords = function (originCoord, originSize, coordRoom1, sizeRoom1, coordRoom2, sizeRoom2) {\n        // проверим - попал ли коридор на комнаты. Вдруг он сместился, нужно подвинуть\n        var coordMin = originCoord - originSize / 2;\n        var coordMax = originCoord + originSize / 2;\n        var newCorridorMaxX = coordMax, newCorridorMinX = coordMin;\n        if (coordMax > (coordRoom1 + sizeRoom1)) {\n            newCorridorMaxX = (coordRoom1 + sizeRoom1);\n        }\n        if (coordMax > (coordRoom2 + sizeRoom2)) {\n            newCorridorMaxX = (coordRoom2 + sizeRoom2);\n        }\n        if (coordMin < (coordRoom1)) {\n            newCorridorMinX = coordRoom1;\n        }\n        if (coordMin < coordRoom2) {\n            newCorridorMinX = coordRoom2;\n        }\n        // исправим положение коридора\n        if (originCoord < (newCorridorMinX + originSize / 2)) {\n            originCoord = newCorridorMinX + originSize / 2;\n        }\n        if (originCoord > (newCorridorMaxX - originSize / 2)) {\n            originCoord = (newCorridorMaxX - originSize / 2);\n        }\n        return { coord: originCoord, size: originSize };\n    };\n    return BSPMazeGenerator;\n}());\nexports.default = BSPMazeGenerator;\n\n\n//# sourceURL=webpack:///./src/lib/BSPMazeGenerator.ts?");

/***/ }),

/***/ "./src/lib/CellularAutomate.ts":
/*!*************************************!*\
  !*** ./src/lib/CellularAutomate.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SUPER_CELL = 9; // клетка в суперпозиции - может принять любое значение\nvar DEAD_CELL = 1; // точно мёртвая. Не изменит состояние при генерации\nvar LIVE_CELL = 0; // точно живая. Не изменит состояние при генерации\nvar SO_DEAD_CELL = 3; // условно мёртвая. Может изменить состояние на следующем шаге\nvar SO_LIVE_CELL = 2; // условно живая. --//--\nvar ZONE_PADDING = 2; // незаполняемый промежуток от границы зоны\nvar ROOM_FILL_MARGIN = 6; // промежуток вокруг комнаты для заполнения случайными клетками\nvar CellularAutomate = /** @class */ (function () {\n    function CellularAutomate(width, height, rooms, corridors) {\n        this.rooms = rooms;\n        this.corridors = corridors;\n        this.width = width;\n        this.height = height;\n        this.map = [];\n    }\n    // метод для пересчёта положения на карте в точке x,y в смещение в массиве\n    CellularAutomate.prototype.coordToOffset = function (x, y) {\n        return y * this.width + x;\n    };\n    // метод для пересчёта смещения в массиве в положение на карте в точке x,y\n    CellularAutomate.prototype.offsetToCoord = function (offset) {\n        var x = offset % this.width;\n        return { x: x, y: (offset - x) / this.width };\n    };\n    CellularAutomate.prototype.initializeMap = function () {\n        // 1. заливаем всю карту \"точно мёртвым\" цветом\n        // 2. проходим по комнатам и коридорам, заливаем место случайно вокруг них \"живыми\"\n        //    так чтобы на границах зон оставались \"точно мёртвые\" клетки\n        // 3. заливаем комнаты и коридоры \"точно живыми клетками\"\n        // 4. карта готова. Дальше отдельным методом прогоняем одну итерацию.\n        //    сколько итераций надо - решает внешний код\n        var _this = this;\n        // заполняем весь массив карты \"мёртвыми\" клетками\n        var mapSize = this.width * this.height;\n        for (var i = 0; i < mapSize; i++) {\n            this.map[i] = DEAD_CELL;\n        }\n        // Далее проходим по всем комнатам, получаем из них зоны, и пространство вокруг\n        // комнаты заполняем клетками в суперпозиции. Аналогично - с коридорами\n        this.rooms.forEach(function (room) {\n            // берём границы, чтобы при заполнении пространства случайно не вылезти за зону\n            var minX = room.tree.x + ZONE_PADDING;\n            var maxX = room.tree.x + room.tree.width - ZONE_PADDING;\n            var minY = room.tree.y + ZONE_PADDING;\n            var maxY = room.tree.y + room.tree.height - ZONE_PADDING;\n            // теперь вокруг комнаты заполняем клетками\n            var fillX = room.x - ROOM_FILL_MARGIN;\n            var fillY = room.y - ROOM_FILL_MARGIN;\n            if (fillX < minX) {\n                fillX = minX;\n            }\n            if (fillY < minY) {\n                fillY = minY;\n            }\n            var fillMaxX = room.x + room.width + ROOM_FILL_MARGIN;\n            var fillMaxY = room.y + room.height + ROOM_FILL_MARGIN;\n            if (fillMaxX > maxX) {\n                fillMaxX = maxX;\n            }\n            if (fillMaxY > maxY) {\n                fillMaxY = maxY;\n            }\n            var roomX = room.x;\n            var roomMaxX = room.x + room.width;\n            var roomY = room.y;\n            var roomMaxY = room.y + room.height;\n            for (var i = fillX; i <= fillMaxX; i++) {\n                for (var j = fillY; j <= fillMaxY; j++) {\n                    // проверим, если это не внутри комнаты - то суперпозиция\n                    // если внутри - то живая клетка\n                    if (i >= roomX && i <= roomMaxX && j >= roomY && j <= roomMaxY) {\n                        _this.map[_this.coordToOffset(i, j)] = LIVE_CELL;\n                    }\n                    else {\n                        _this.map[_this.coordToOffset(i, j)] = SUPER_CELL;\n                    }\n                }\n            }\n        });\n        this.corridors.forEach(function (corridor) {\n            // теперь вокруг коридора заполняем клетками в суперпозиции\n            var fillX = corridor.x - ROOM_FILL_MARGIN;\n            var fillY = corridor.y - ROOM_FILL_MARGIN;\n            var fillMaxX = corridor.x + corridor.width + ROOM_FILL_MARGIN;\n            var fillMaxY = corridor.y + corridor.height + ROOM_FILL_MARGIN;\n            if (fillX < 0) {\n                fillX = 0;\n            }\n            if (fillY < 0) {\n                fillY = 0;\n            }\n            if (fillMaxX > _this.width) {\n                fillMaxX = _this.width;\n            }\n            if (fillMaxY > _this.height) {\n                fillMaxY = _this.height;\n            }\n            var roomX = corridor.x;\n            var roomMaxX = corridor.x + corridor.width;\n            var roomY = corridor.y;\n            var roomMaxY = corridor.y + corridor.height;\n            for (var i = fillX; i <= fillMaxX; i++) {\n                for (var j = fillY; j <= fillMaxY; j++) {\n                    if (_this.map[_this.coordToOffset(i, j)] === LIVE_CELL) {\n                        continue;\n                    }\n                    // проверим, если это не внутри коридора - то суперпозиция\n                    // если внутри - то живая клетка\n                    if (i >= roomX && i <= roomMaxX && j >= roomY && j <= roomMaxY) {\n                        _this.map[_this.coordToOffset(i, j)] = LIVE_CELL;\n                    }\n                    else {\n                        _this.map[_this.coordToOffset(i, j)] = SUPER_CELL;\n                    }\n                }\n            }\n        });\n        // Всегда по периметру заполняем мёртвыми клетками. Выхода нет.\n        for (var x = 0; x < this.width; x++) {\n            this.map[this.coordToOffset(x, 0)] = DEAD_CELL;\n            this.map[this.coordToOffset(x, this.height - 1)] = DEAD_CELL;\n        }\n        for (var y = 0; y < this.height; y++) {\n            this.map[this.coordToOffset(0, y)] = DEAD_CELL;\n            this.map[this.coordToOffset(this.width - 1, y)] = DEAD_CELL;\n        }\n        this.map.forEach(function (value, index, map) {\n            if (value === SUPER_CELL) {\n                map[index] = Math.random() > .5 ? SO_LIVE_CELL : SO_DEAD_CELL;\n            }\n        });\n    };\n    CellularAutomate.prototype.renderMap = function (graphics) {\n        var _this = this;\n        graphics.setDefaultStyles({\n            lineStyle: {\n                width: 1,\n                color: 0xFF0000,\n                alpha: 1\n            },\n            fillStyle: {\n                color: 0xFF0000,\n                alpha: 1\n            }\n        });\n        this.map.forEach(function (value, index) {\n            if (value === DEAD_CELL) {\n                return;\n            }\n            var color = 0XFFFFFF;\n            switch (value) {\n                case LIVE_CELL:\n                    color = 0xFFFFFF;\n                    break;\n                case SO_LIVE_CELL:\n                    color = 0xFFFFFF;\n                    break;\n                case SO_DEAD_CELL:\n                    color = 0x000000;\n                    break;\n            }\n            var point = _this.offsetToCoord(index);\n            graphics.fillStyle(color, 1);\n            graphics.fillPoint(point.x, point.y);\n        });\n    };\n    // прогоняет нужное количество итераций по подготовленной карте\n    CellularAutomate.prototype.run = function (iterations) {\n        if (iterations === void 0) { iterations = 1; }\n        iterations--;\n        // воспользуемся правилом отсюда: http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels\n        // 1. клетка становится стеной, если она была стеной и >=4 соседей были стенами\n        // 2. или клетка становится стеной, если она НЕ была стеной и >=5 соседей были стенами\n        var newMap = this.map;\n        var mapSize = this.width * this.height;\n        // для каких клеток есть смысл смотреть на соседей:\n        var minCellIndex = this.width + 2;\n        var maxCellIndex = mapSize - this.width - 2;\n        var _loop_1 = function (i) {\n            if (this_1.map[i] === DEAD_CELL || this_1.map[i] === LIVE_CELL) {\n                newMap[i] = this_1.map[i];\n                return \"continue\";\n            }\n            var isWasWall = this_1.map[i] === SO_DEAD_CELL;\n            // соберём \"соседей\" клетки на карте из массива\n            var neighbors = [\n                this_1.map[i - this_1.width - 1],\n                this_1.map[i - this_1.width],\n                this_1.map[i - this_1.width + 1],\n                this_1.map[i - 1],\n                this_1.map[i + 1],\n                this_1.map[i + this_1.width - 1],\n                this_1.map[i + this_1.width],\n                this_1.map[i + this_1.width + 1],\n            ];\n            var count = 0;\n            neighbors.forEach(function (value) {\n                if (value === DEAD_CELL || value === SO_DEAD_CELL) {\n                    count++;\n                }\n            });\n            if ((isWasWall && count >= 4) || (!isWasWall && count >= 5)) {\n                newMap[i] = SO_DEAD_CELL;\n            }\n            else {\n                newMap[i] = SO_LIVE_CELL;\n            }\n        };\n        var this_1 = this;\n        for (var i = minCellIndex; i < maxCellIndex; i++) {\n            _loop_1(i);\n        }\n        // новую карту посчитали, теперь перекладываем её в текущее состояние\n        this.map = newMap;\n        if (iterations > 0) {\n            this.run(iterations);\n        }\n    };\n    /**\n     * Возвращает текущее состояние карты в виде массива с двумя типами клеток: мёртвые или живые\n     */\n    CellularAutomate.prototype.getMap = function () {\n        var outMap = [];\n        for (var x = 0; x < this.width; x++) {\n            for (var y = 0; y < this.height; y++) {\n                var offset = this.coordToOffset(x, y);\n                var cell = this.map[offset];\n                var outVal = cell;\n                if (cell === SO_DEAD_CELL) {\n                    outVal = DEAD_CELL;\n                }\n                else if (cell === SO_LIVE_CELL) {\n                    outVal = LIVE_CELL;\n                }\n                outMap.push(outVal);\n            }\n        }\n        return outMap;\n    };\n    return CellularAutomate;\n}());\nexports.default = CellularAutomate;\n\n\n//# sourceURL=webpack:///./src/lib/CellularAutomate.ts?");

/***/ }),

/***/ "./src/lib/KeyGenerator.ts":
/*!*********************************!*\
  !*** ./src/lib/KeyGenerator.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar KeyGenerator = /** @class */ (function () {\n    function KeyGenerator() {\n    }\n    KeyGenerator.getNextKey = function (prefix) {\n        var keyToReturn;\n        if (prefix === undefined) {\n            keyToReturn = '' + KeyGenerator.key;\n            KeyGenerator.key++;\n            return keyToReturn;\n        }\n        if (!KeyGenerator.prefixedKeys.hasOwnProperty(prefix)) {\n            KeyGenerator.prefixedKeys[prefix] = 1;\n        }\n        keyToReturn = prefix + KeyGenerator.prefixedKeys[prefix];\n        KeyGenerator.prefixedKeys[prefix]++;\n        return keyToReturn;\n    };\n    KeyGenerator.resetAll = function () {\n        KeyGenerator.key = 1;\n        KeyGenerator.prefixedKeys = {};\n    };\n    KeyGenerator.key = 1;\n    KeyGenerator.prefixedKeys = {};\n    return KeyGenerator;\n}());\nexports.default = KeyGenerator;\n\n\n//# sourceURL=webpack:///./src/lib/KeyGenerator.ts?");

/***/ }),

/***/ "./src/lib/MathUtils.ts":
/*!******************************!*\
  !*** ./src/lib/MathUtils.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MathUtils = /** @class */ (function () {\n    function MathUtils() {\n    }\n    MathUtils.getRandomIntegerBetween = function (from, to) {\n        return Math.floor((Math.random() * (to - from + 1)) + from);\n    };\n    return MathUtils;\n}());\nexports.default = MathUtils;\n\n\n//# sourceURL=webpack:///./src/lib/MathUtils.ts?");

/***/ }),

/***/ "./src/lib/Maze/StoneMazeTilesProcessor.ts":
/*!*************************************************!*\
  !*** ./src/lib/Maze/StoneMazeTilesProcessor.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Это класс, который принимает на вход карту уровня в виде массива данных,\n * из генератора, где 0 - это блок, а 1 - это проход.\n * И на основе этого массива генерирует новую карту уровня, расставляя\n * соответстующие взаимному расположению элементов уровня тайлы\n * из WaterMazeTiles[Extruded]\n */\nvar TilesEnum_1 = __webpack_require__(/*! ./TilesEnum */ \"./src/lib/Maze/TilesEnum.ts\");\nvar StoneMazeTilesProcessor = /** @class */ (function () {\n    function StoneMazeTilesProcessor() {\n    }\n    /**\n     * Возвращает массив со значениями тайлов, которые считаем \"блоками\"\n     */\n    StoneMazeTilesProcessor.getCollisionTilesIndexes = function () {\n        return [\n            TilesEnum_1.default.GRASS_BORDER_TOP_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_TOP,\n            TilesEnum_1.default.GRASS_BORDER_TOP_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_LEFT,\n            TilesEnum_1.default.GRASS_CENTER,\n            TilesEnum_1.default.GRASS_BORDER_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_RIGHT,\n            TilesEnum_1.default.GRASS_SINGLE_BUSH,\n            TilesEnum_1.default.GRASS_BORDER_TOP_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_TOP,\n            TilesEnum_1.default.GRASS_BORDER_TOP_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_LEFT,\n            TilesEnum_1.default.GRASS_CENTER,\n            TilesEnum_1.default.GRASS_BORDER_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_RIGHT,\n            TilesEnum_1.default.GRASS_CROSS_TOP,\n            TilesEnum_1.default.GRASS_CROSS_LEFT,\n            TilesEnum_1.default.GRASS_CROSS_CENTER,\n            TilesEnum_1.default.GRASS_CROSS_RIGHT,\n            TilesEnum_1.default.GRASS_CROSS_BOTTOM,\n            TilesEnum_1.default.GRASS_CORNER_TOP_LEFT,\n            TilesEnum_1.default.GRASS_CORNER_TOP_RIGHT,\n            TilesEnum_1.default.GRASS_CORNER_BOTTOM_LEFT,\n            TilesEnum_1.default.GRASS_CORNER_BOTTOM_RIGHT,\n        ];\n    };\n    /**\n     * Расставляет тайлы из спрайта водяного лабиринта в уровень\n     * @param level\n     * @param rowWidth\n     */\n    StoneMazeTilesProcessor.placeTiles = function (level, rowWidth) {\n        var newLevel = [];\n        var block = 1;\n        var pass = 0;\n        for (var i = 0; i < level.length; i++) {\n            // Соседи\n            var n = [\n                level[i - rowWidth - 1],\n                level[i - rowWidth],\n                level[i - rowWidth + 1],\n                level[i - 1],\n                level[i + 1],\n                level[i + rowWidth - 1],\n                level[i + rowWidth],\n                level[i + rowWidth + 1],\n            ];\n            // 0 - блок, 1 - проход\n            if (level[i] === pass) {\n                // если проход - рисуем воду и всё тут\n                newLevel[i] = TilesEnum_1.default.WATER;\n                // если все соседи - проход, то с некоторым шансом поставим кувшинку\n                if (n[0] === pass && n[1] === pass && n[2] === pass && n[3] === pass &&\n                    n[4] === pass && n[5] === pass && n[6] === pass && n[7] === pass) {\n                    var chance = Math.random();\n                    // Шанс на кувшинку с цветком - 0.2%\n                    if (chance <= .002) {\n                        newLevel[i] = TilesEnum_1.default.WATER_LILY_FLOWER;\n                    }\n                    // Шанс на кувшинку без цветка - 1%\n                    else if (chance <= .01) {\n                        newLevel[i] = TilesEnum_1.default.WATER_LILY;\n                    }\n                }\n                // если соседи - блоки, то нужно поставить воду с камышами\n                // если 4 соседа-блока\n                if (n[1] === block && n[3] === block && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_CENTER;\n                }\n                // если 3 соседа-блока\n                // это элементы фигуры-креста\n                //   X\n                //  XXX\n                //   X\n                else if (n[1] === block && n[3] === block && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_TOP;\n                }\n                else if (n[1] === block && n[3] === block && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_LEFT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_RIGHT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_BOTTOM;\n                }\n                // если 2 соседа-блока\n                else if (n[1] === pass && n[3] === pass && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_BOTTOM_RIGHT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_BOTTOM_LEFT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_TOP_RIGHT;\n                }\n                else if (n[1] === block && n[3] === block && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_TOP_LEFT;\n                }\n                // если 1 сосед-блок\n                else if (n[1] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_TOP;\n                }\n                else if (n[3] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_LEFT;\n                }\n                else if (n[4] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_RIGHT;\n                }\n                else if (n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_BOTTOM;\n                }\n            }\n            else {\n                // если у нас блок, то смотрим по соседям, какой блок нам рисовать\n                // ПРОВЕРЯЕМ ЧЕТЫРЁХ ПРЯМЫХ СОСЕДЕЙ - верх, низ, лево право\n                // если 4 соседа-прохода\n                if (n[1] === pass && n[3] === pass && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_SINGLE_BUSH;\n                }\n                // если 3 соседа-прохода\n                // это элементы фигуры-креста\n                //   X\n                //  XXX\n                //   X\n                else if (n[1] === pass && n[3] === pass && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_TOP;\n                }\n                else if (n[1] === pass && n[3] === pass && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_LEFT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_RIGHT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_BOTTOM;\n                }\n                // если 2 соседа-прохода\n                else if (n[1] === pass && n[3] === pass && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_TOP_LEFT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_TOP_RIGHT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_BOTTOM_LEFT;\n                }\n                else if (n[1] === block && n[3] === block && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_BOTTOM_RIGHT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_WALL_HORIZONTAL;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_WALL_VERTICAL;\n                }\n                // если 1 сосед-проход\n                else if (n[1] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_TOP;\n                }\n                else if (n[3] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_LEFT;\n                }\n                else if (n[4] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_RIGHT;\n                }\n                else if (n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_BOTTOM;\n                }\n                // ПРОВЕРИМ ДИАГОНАЛЬНЫХ СОСЕДЕЙ\n                // если со всех сторон блоки, проверим диагональных соседей\n                else if (n[1] === block && n[3] === block && n[4] === block && n[6] === block) {\n                    // все диагонали - проходы\n                    if (n[0] === pass && n[2] === pass && n[5] === pass && n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CROSS_CENTER;\n                    }\n                    // две диагонали с одной стороны - проход\n                    else if (n[0] === pass && n[2] === pass && n[5] === block && n[7] === block) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_TOP;\n                    }\n                    else if (n[0] === block && n[2] === block && n[5] === pass && n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_BOTTOM;\n                    }\n                    else if (n[0] === pass && n[2] === block && n[5] === pass && n[7] === block) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_LEFT;\n                    }\n                    else if (n[0] === block && n[2] === pass && n[5] === block && n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_RIGHT;\n                    }\n                    // одна из диагоналей - проход\n                    else if (n[0] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_BOTTOM_RIGHT;\n                    }\n                    else if (n[2] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_BOTTOM_LEFT;\n                    }\n                    else if (n[5] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_TOP_RIGHT;\n                    }\n                    else if (n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_TOP_LEFT;\n                    }\n                    else {\n                        if (Math.random() < 0.03) {\n                            newLevel[i] = TilesEnum_1.default.GRASS_CENTER_WITH_SEDGE;\n                        }\n                        else {\n                            newLevel[i] = TilesEnum_1.default.GRASS_CENTER;\n                        }\n                    }\n                }\n                else {\n                    // c шансом 1% добавим в траву камыши\n                    if (Math.random() < 0.03) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_WITH_SEDGE;\n                    }\n                    else {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER;\n                    }\n                }\n            }\n        }\n        return newLevel;\n    };\n    return StoneMazeTilesProcessor;\n}());\nexports.default = StoneMazeTilesProcessor;\n\n\n//# sourceURL=webpack:///./src/lib/Maze/StoneMazeTilesProcessor.ts?");

/***/ }),

/***/ "./src/lib/Maze/TilesEnum.ts":
/*!***********************************!*\
  !*** ./src/lib/Maze/TilesEnum.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TilesEnum;\n(function (TilesEnum) {\n    TilesEnum[TilesEnum[\"WATER\"] = 11] = \"WATER\";\n    TilesEnum[TilesEnum[\"WATER_LILY\"] = 41] = \"WATER_LILY\";\n    TilesEnum[TilesEnum[\"WATER_LILY_FLOWER\"] = 47] = \"WATER_LILY_FLOWER\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_TOP_LEFT\"] = 13] = \"WATER_SEDGE_TOP_LEFT\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_TOP\"] = 14] = \"WATER_SEDGE_TOP\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_TOP_RIGHT\"] = 15] = \"WATER_SEDGE_TOP_RIGHT\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_LEFT\"] = 40] = \"WATER_SEDGE_LEFT\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_RIGHT\"] = 42] = \"WATER_SEDGE_RIGHT\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_BOTTOM_LEFT\"] = 67] = \"WATER_SEDGE_BOTTOM_LEFT\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_BOTTOM\"] = 68] = \"WATER_SEDGE_BOTTOM\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_BOTTOM_RIGHT\"] = 69] = \"WATER_SEDGE_BOTTOM_RIGHT\";\n    TilesEnum[TilesEnum[\"WATER_CROSS_SEDGE_TOP\"] = 176] = \"WATER_CROSS_SEDGE_TOP\";\n    TilesEnum[TilesEnum[\"WATER_CROSS_SEDGE_LEFT\"] = 202] = \"WATER_CROSS_SEDGE_LEFT\";\n    TilesEnum[TilesEnum[\"WATER_CROSS_SEDGE_RIGHT\"] = 204] = \"WATER_CROSS_SEDGE_RIGHT\";\n    TilesEnum[TilesEnum[\"WATER_CROSS_SEDGE_BOTTOM\"] = 230] = \"WATER_CROSS_SEDGE_BOTTOM\";\n    TilesEnum[TilesEnum[\"WATER_SEDGE_CENTER\"] = 122] = \"WATER_SEDGE_CENTER\";\n    TilesEnum[TilesEnum[\"GRASS_SINGLE_BUSH\"] = 113] = \"GRASS_SINGLE_BUSH\";\n    // границы травы, переход к воде\n    TilesEnum[TilesEnum[\"GRASS_BORDER_TOP_LEFT\"] = 4] = \"GRASS_BORDER_TOP_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_TOP\"] = 5] = \"GRASS_BORDER_TOP\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_TOP_RIGHT\"] = 6] = \"GRASS_BORDER_TOP_RIGHT\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_LEFT\"] = 31] = \"GRASS_BORDER_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_CENTER\"] = 32] = \"GRASS_CENTER\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_RIGHT\"] = 33] = \"GRASS_BORDER_RIGHT\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_BOTTOM_LEFT\"] = 58] = \"GRASS_BORDER_BOTTOM_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_BOTTOM\"] = 59] = \"GRASS_BORDER_BOTTOM\";\n    TilesEnum[TilesEnum[\"GRASS_BORDER_BOTTOM_RIGHT\"] = 60] = \"GRASS_BORDER_BOTTOM_RIGHT\";\n    TilesEnum[TilesEnum[\"GRASS_CENTER_WITH_SEDGE\"] = 35] = \"GRASS_CENTER_WITH_SEDGE\";\n    // \"крест\" из травы. Например для отрисовки узких стен или одиночных полу-островков\n    TilesEnum[TilesEnum[\"GRASS_CROSS_TOP\"] = 167] = \"GRASS_CROSS_TOP\";\n    TilesEnum[TilesEnum[\"GRASS_CROSS_LEFT\"] = 193] = \"GRASS_CROSS_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_CROSS_CENTER\"] = 194] = \"GRASS_CROSS_CENTER\";\n    TilesEnum[TilesEnum[\"GRASS_CROSS_RIGHT\"] = 195] = \"GRASS_CROSS_RIGHT\";\n    TilesEnum[TilesEnum[\"GRASS_CROSS_BOTTOM\"] = 221] = \"GRASS_CROSS_BOTTOM\";\n    // Углы, соседствующие с единственным блоком-проходом, расположенные от него по диагонали\n    TilesEnum[TilesEnum[\"GRASS_CORNER_TOP_LEFT\"] = 409] = \"GRASS_CORNER_TOP_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_CORNER_TOP_RIGHT\"] = 410] = \"GRASS_CORNER_TOP_RIGHT\";\n    TilesEnum[TilesEnum[\"GRASS_CORNER_BOTTOM_LEFT\"] = 436] = \"GRASS_CORNER_BOTTOM_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_CORNER_BOTTOM_RIGHT\"] = 437] = \"GRASS_CORNER_BOTTOM_RIGHT\";\n    // блок травы, с двумя диагональными соседями\n    TilesEnum[TilesEnum[\"GRASS_CENTER_TWO_WATERS_AT_BOTTOM\"] = 329] = \"GRASS_CENTER_TWO_WATERS_AT_BOTTOM\";\n    TilesEnum[TilesEnum[\"GRASS_CENTER_TWO_WATERS_AT_RIGHT\"] = 355] = \"GRASS_CENTER_TWO_WATERS_AT_RIGHT\";\n    TilesEnum[TilesEnum[\"GRASS_CENTER_TWO_WATERS_AT_LEFT\"] = 357] = \"GRASS_CENTER_TWO_WATERS_AT_LEFT\";\n    TilesEnum[TilesEnum[\"GRASS_CENTER_TWO_WATERS_AT_TOP\"] = 383] = \"GRASS_CENTER_TWO_WATERS_AT_TOP\";\n    // стены из травы\n    TilesEnum[TilesEnum[\"GRASS_WALL_HORIZONTAL\"] = 86] = \"GRASS_WALL_HORIZONTAL\";\n    TilesEnum[TilesEnum[\"GRASS_WALL_VERTICAL\"] = 112] = \"GRASS_WALL_VERTICAL\";\n})(TilesEnum || (TilesEnum = {}));\nexports.default = TilesEnum;\n\n\n//# sourceURL=webpack:///./src/lib/Maze/TilesEnum.ts?");

/***/ }),

/***/ "./src/lib/Maze/WaterMazeTilesProcessor.ts":
/*!*************************************************!*\
  !*** ./src/lib/Maze/WaterMazeTilesProcessor.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Это класс, который принимает на вход карту уровня в виде массива данных,\n * из генератора, где 0 - это блок, а 1 - это проход.\n * И на основе этого массива генерирует новую карту уровня, расставляя\n * соответстующие взаимному расположению элементов уровня тайлы\n * из WaterMazeTiles[Extruded]\n */\nvar TilesEnum_1 = __webpack_require__(/*! ./TilesEnum */ \"./src/lib/Maze/TilesEnum.ts\");\nvar WaterMazeTilesProcessor = /** @class */ (function () {\n    function WaterMazeTilesProcessor() {\n    }\n    /**\n     * Возвращает массив со значениями тайлов, которые считаем \"блоками\"\n     */\n    WaterMazeTilesProcessor.getCollisionTilesIndexes = function () {\n        return [\n            TilesEnum_1.default.GRASS_BORDER_TOP_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_TOP,\n            TilesEnum_1.default.GRASS_BORDER_TOP_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_LEFT,\n            TilesEnum_1.default.GRASS_CENTER,\n            TilesEnum_1.default.GRASS_BORDER_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_RIGHT,\n            TilesEnum_1.default.GRASS_SINGLE_BUSH,\n            TilesEnum_1.default.GRASS_BORDER_TOP_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_TOP,\n            TilesEnum_1.default.GRASS_BORDER_TOP_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_LEFT,\n            TilesEnum_1.default.GRASS_CENTER,\n            TilesEnum_1.default.GRASS_BORDER_RIGHT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_LEFT,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM,\n            TilesEnum_1.default.GRASS_BORDER_BOTTOM_RIGHT,\n            TilesEnum_1.default.GRASS_CROSS_TOP,\n            TilesEnum_1.default.GRASS_CROSS_LEFT,\n            TilesEnum_1.default.GRASS_CROSS_CENTER,\n            TilesEnum_1.default.GRASS_CROSS_RIGHT,\n            TilesEnum_1.default.GRASS_CROSS_BOTTOM,\n            TilesEnum_1.default.GRASS_CORNER_TOP_LEFT,\n            TilesEnum_1.default.GRASS_CORNER_TOP_RIGHT,\n            TilesEnum_1.default.GRASS_CORNER_BOTTOM_LEFT,\n            TilesEnum_1.default.GRASS_CORNER_BOTTOM_RIGHT,\n        ];\n    };\n    /**\n     * Расставляет тайлы из спрайта водяного лабиринта в уровень\n     * @param level\n     * @param rowWidth\n     */\n    WaterMazeTilesProcessor.placeTiles = function (level, rowWidth) {\n        var newLevel = [];\n        var block = 1;\n        var pass = 0;\n        for (var i = 0; i < level.length; i++) {\n            // Соседи\n            var n = [\n                level[i - rowWidth - 1],\n                level[i - rowWidth],\n                level[i - rowWidth + 1],\n                level[i - 1],\n                level[i + 1],\n                level[i + rowWidth - 1],\n                level[i + rowWidth],\n                level[i + rowWidth + 1],\n            ];\n            // 0 - блок, 1 - проход\n            if (level[i] === pass) {\n                // если проход - рисуем воду и всё тут\n                newLevel[i] = TilesEnum_1.default.WATER;\n                // если все соседи - проход, то с некоторым шансом поставим кувшинку\n                if (n[0] === pass && n[1] === pass && n[2] === pass && n[3] === pass &&\n                    n[4] === pass && n[5] === pass && n[6] === pass && n[7] === pass) {\n                    var chance = Math.random();\n                    // Шанс на кувшинку с цветком - 0.2%\n                    if (chance <= .002) {\n                        newLevel[i] = TilesEnum_1.default.WATER_LILY_FLOWER;\n                    }\n                    // Шанс на кувшинку без цветка - 1%\n                    else if (chance <= .01) {\n                        newLevel[i] = TilesEnum_1.default.WATER_LILY;\n                    }\n                }\n                // если соседи - блоки, то нужно поставить воду с камышами\n                // если 4 соседа-блока\n                if (n[1] === block && n[3] === block && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_CENTER;\n                }\n                // если 3 соседа-блока\n                // это элементы фигуры-креста\n                //   X\n                //  XXX\n                //   X\n                else if (n[1] === block && n[3] === block && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_TOP;\n                }\n                else if (n[1] === block && n[3] === block && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_LEFT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_RIGHT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_CROSS_SEDGE_BOTTOM;\n                }\n                // если 2 соседа-блока\n                else if (n[1] === pass && n[3] === pass && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_BOTTOM_RIGHT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_BOTTOM_LEFT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_TOP_RIGHT;\n                }\n                else if (n[1] === block && n[3] === block && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_TOP_LEFT;\n                }\n                // если 1 сосед-блок\n                else if (n[1] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_TOP;\n                }\n                else if (n[3] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_LEFT;\n                }\n                else if (n[4] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_RIGHT;\n                }\n                else if (n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.WATER_SEDGE_BOTTOM;\n                }\n            }\n            else {\n                // если у нас блок, то смотрим по соседям, какой блок нам рисовать\n                // ПРОВЕРЯЕМ ЧЕТЫРЁХ ПРЯМЫХ СОСЕДЕЙ - верх, низ, лево право\n                // если 4 соседа-прохода\n                if (n[1] === pass && n[3] === pass && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_SINGLE_BUSH;\n                }\n                // если 3 соседа-прохода\n                // это элементы фигуры-креста\n                //   X\n                //  XXX\n                //   X\n                else if (n[1] === pass && n[3] === pass && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_TOP;\n                }\n                else if (n[1] === pass && n[3] === pass && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_LEFT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_RIGHT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_CROSS_BOTTOM;\n                }\n                // если 2 соседа-прохода\n                else if (n[1] === pass && n[3] === pass && n[4] === block && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_TOP_LEFT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_TOP_RIGHT;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_BOTTOM_LEFT;\n                }\n                else if (n[1] === block && n[3] === block && n[4] === pass && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_BOTTOM_RIGHT;\n                }\n                else if (n[1] === pass && n[3] === block && n[4] === block && n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_WALL_HORIZONTAL;\n                }\n                else if (n[1] === block && n[3] === pass && n[4] === pass && n[6] === block) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_WALL_VERTICAL;\n                }\n                // если 1 сосед-проход\n                else if (n[1] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_TOP;\n                }\n                else if (n[3] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_LEFT;\n                }\n                else if (n[4] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_RIGHT;\n                }\n                else if (n[6] === pass) {\n                    newLevel[i] = TilesEnum_1.default.GRASS_BORDER_BOTTOM;\n                }\n                // ПРОВЕРИМ ДИАГОНАЛЬНЫХ СОСЕДЕЙ\n                // если со всех сторон блоки, проверим диагональных соседей\n                else if (n[1] === block && n[3] === block && n[4] === block && n[6] === block) {\n                    // все диагонали - проходы\n                    if (n[0] === pass && n[2] === pass && n[5] === pass && n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CROSS_CENTER;\n                    }\n                    // две диагонали с одной стороны - проход\n                    else if (n[0] === pass && n[2] === pass && n[5] === block && n[7] === block) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_TOP;\n                    }\n                    else if (n[0] === block && n[2] === block && n[5] === pass && n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_BOTTOM;\n                    }\n                    else if (n[0] === pass && n[2] === block && n[5] === pass && n[7] === block) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_LEFT;\n                    }\n                    else if (n[0] === block && n[2] === pass && n[5] === block && n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_TWO_WATERS_AT_RIGHT;\n                    }\n                    // одна из диагоналей - проход\n                    else if (n[0] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_BOTTOM_RIGHT;\n                    }\n                    else if (n[2] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_BOTTOM_LEFT;\n                    }\n                    else if (n[5] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_TOP_RIGHT;\n                    }\n                    else if (n[7] === pass) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CORNER_TOP_LEFT;\n                    }\n                    else {\n                        if (Math.random() < 0.03) {\n                            newLevel[i] = TilesEnum_1.default.GRASS_CENTER_WITH_SEDGE;\n                        }\n                        else {\n                            newLevel[i] = TilesEnum_1.default.GRASS_CENTER;\n                        }\n                    }\n                }\n                else {\n                    // c шансом 1% добавим в траву камыши\n                    if (Math.random() < 0.03) {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER_WITH_SEDGE;\n                    }\n                    else {\n                        newLevel[i] = TilesEnum_1.default.GRASS_CENTER;\n                    }\n                }\n            }\n        }\n        return newLevel;\n    };\n    return WaterMazeTilesProcessor;\n}());\nexports.default = WaterMazeTilesProcessor;\n\n\n//# sourceURL=webpack:///./src/lib/Maze/WaterMazeTilesProcessor.ts?");

/***/ }),

/***/ "./src/lib/Tilemap/Parse2DMultiLayerArray.ts":
/*!***************************************************!*\
  !*** ./src/lib/Tilemap/Parse2DMultiLayerArray.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Tile = Phaser.Tilemaps.Tile;\nvar MapData = Phaser.Tilemaps.MapData;\nvar LayerData = Phaser.Tilemaps.LayerData;\nvar Formats = Phaser.Tilemaps.Formats;\n/**\n * Parses a 2D array of tile indexes into a new MapData object with a single layer.\n *\n * @function Parse2DMultiLayerArray\n * @since 3.0.0\n *\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\n * @param {integer[][]} layersData - array of layers tile indexes arrays. Every layer is array of integers\n * @param {integer} widthInTiles -\n * @param {integer} heightInTiles -\n * @param {integer} tileWidth - The width of a tile in pixels.\n * @param {integer} tileHeight - The height of a tile in pixels.\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\n * the tile data doesn't need to change then setting this value to `true` will help with memory\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\n * the default value set.\n *\n * @return {Phaser.Tilemaps.MapData} The MapData object.\n */\nvar Parse2DMultiLayerArray = function (name, layersData, widthInTiles, heightInTiles, tileWidth, tileHeight, insertNull) {\n    var mapData = new MapData({\n        name: name,\n        tileWidth: tileWidth,\n        tileHeight: tileHeight,\n        format: Formats.ARRAY_2D,\n    });\n    mapData.width = widthInTiles;\n    mapData.height = heightInTiles;\n    mapData.widthInPixels = widthInTiles * tileWidth;\n    mapData.heightInPixels = heightInTiles * tileHeight;\n    var layers = [];\n    for (var i = 0; i < layersData.length; i++) {\n        var tiles = [];\n        var height = heightInTiles;\n        var width = 0;\n        var layerData = new LayerData({\n            tileWidth: tileWidth,\n            tileHeight: tileHeight\n        });\n        var data = layersData[i];\n        for (var y = 0; y < data.length; y++) {\n            tiles[y] = [];\n            var row = data[y];\n            for (var x = 0; x < row.length; x++) {\n                var tileIndex = parseInt(row[x], 10);\n                if (isNaN(tileIndex) || tileIndex === -1) {\n                    tiles[y][x] = insertNull\n                        ? null\n                        : new Tile(layerData, -1, x, y, tileWidth, tileHeight, tileWidth, tileHeight);\n                }\n                else {\n                    tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight, tileWidth, tileHeight);\n                }\n            }\n            if (width === 0) {\n                width = row.length;\n            }\n        }\n        layerData.width = width;\n        layerData.height = height;\n        layerData.widthInPixels = width * tileWidth;\n        layerData.heightInPixels = height * tileHeight;\n        layerData.data = tiles;\n        layers.push(layerData);\n    }\n    mapData.layers = layers;\n    return mapData;\n};\nexports.default = Parse2DMultiLayerArray;\n\n\n//# sourceURL=webpack:///./src/lib/Tilemap/Parse2DMultiLayerArray.ts?");

/***/ }),

/***/ "./src/lib/Tilemap/ParseToMultiLayerTilemap.ts":
/*!*****************************************************!*\
  !*** ./src/lib/Tilemap/ParseToMultiLayerTilemap.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Tilemap = Phaser.Tilemaps.Tilemap;\nvar MapData = Phaser.Tilemaps.MapData;\nvar Parse = Phaser.Tilemaps.Parsers.Parse;\nvar Parse2DMultiLayerArray_1 = __webpack_require__(/*! ./Parse2DMultiLayerArray */ \"./src/lib/Tilemap/Parse2DMultiLayerArray.ts\");\n/**\n * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When\n * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from\n * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For\n * an empty map, you should specify tileWidth, tileHeight, width & height.\n *\n * @function Phaser.Tilemaps.ParseToTilemap\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\n * @param {integer} [tileWidth=32] - The width of a tile in pixels.\n * @param {integer} [tileHeight=32] - The height of a tile in pixels.\n * @param {integer} [width] - The width of the map in tiles.\n * @param {integer} [height] - The height of the map in tiles.\n * @param {integer[][]} [layersData] - Instead of loading from the cache, you can also load directly from\n * a 2D array of tile indexes.\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\n * the tile data doesn't need to change then setting this value to `true` will help with memory\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\n * the default value set.\n *\n * @return {Phaser.Tilemaps.Tilemap}\n */\nfunction parseToMultiLayerTilemap(scene, key, tileWidth, tileHeight, width, height, layersData, insertNull) {\n    if (insertNull === void 0) { insertNull = false; }\n    if (tileWidth === undefined) {\n        tileWidth = 32;\n    }\n    if (tileHeight === undefined) {\n        tileHeight = 32;\n    }\n    if (width === undefined) {\n        width = 10;\n    }\n    if (height === undefined) {\n        height = 10;\n    }\n    if (insertNull === undefined) {\n        insertNull = false;\n    }\n    var mapData = null;\n    // вот здесь использовать свой новый парсер\n    // Если передали данные - генерируем из них. Если не передали - пробуем найти в кэше\n    if (Array.isArray(layersData)) {\n        var name_1 = key !== undefined ? key : 'map';\n        mapData = Parse2DMultiLayerArray_1.default(name_1, layersData, width, height, tileWidth, tileHeight, insertNull);\n    }\n    else if (key !== undefined) {\n        var tilemapData = scene.cache.tilemap.get(key);\n        if (!tilemapData) {\n            console.warn('No map data found for key ' + key);\n        }\n        else {\n            mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);\n        }\n    }\n    if (mapData === null) {\n        mapData = new MapData({\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: width,\n            height: height\n        });\n    }\n    return new Tilemap(scene, mapData);\n}\nexports.default = parseToMultiLayerTilemap;\n\n\n//# sourceURL=webpack:///./src/lib/Tilemap/ParseToMultiLayerTilemap.ts?");

/***/ }),

/***/ "./src/lib/utils/ObjectUtils.ts":
/*!**************************************!*\
  !*** ./src/lib/utils/ObjectUtils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObjectUtils = void 0;\nvar ObjectUtils = /** @class */ (function () {\n    function ObjectUtils() {\n    }\n    // --------------------------------------------------------------------\n    ObjectUtils.loadJson = function (fileName) {\n        return new Promise(function (resolve, reject) {\n            var request = new XMLHttpRequest();\n            request.open('GET', fileName, true);\n            request.responseType = 'json';\n            request.onload = function () {\n                if (request.status === 200) {\n                    resolve(request.response);\n                }\n                else {\n                    reject(new Error(\"Error loading \" + fileName + \": \" + request.statusText));\n                }\n            };\n            request.onerror = function () {\n                reject(new Error(\"Network error while loading \" + fileName));\n            };\n            request.send();\n        });\n    };\n    // --------------------------------------------------------------------\n    ObjectUtils.loadValuesIntoObject = function (jsonData, targetObject) {\n        console.log(\"----- loading values into \" + targetObject.name + \" -----\");\n        for (var property in jsonData) {\n            console.log(\"name = \" + property + \", value = \" + jsonData[property]);\n            targetObject[property] = jsonData[property];\n        }\n        console.log(\"------------------------------------------------\");\n    };\n    return ObjectUtils;\n}());\nexports.ObjectUtils = ObjectUtils;\n\n\n//# sourceURL=webpack:///./src/lib/utils/ObjectUtils.ts?");

/***/ }),

/***/ "./src/scenes/Boot.ts":
/*!****************************!*\
  !*** ./src/scenes/Boot.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Boot = void 0;\nvar SceneBase_1 = __webpack_require__(/*! ./SceneBase */ \"./src/scenes/SceneBase.ts\");\nvar Boot = /** @class */ (function (_super) {\n    __extends(Boot, _super);\n    function Boot() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // --------------------------------------------------------------------\n    Boot.prototype.create = function () {\n        console.log(\"Boot\");\n        this.scene.start(\"Preloader\");\n    };\n    return Boot;\n}(SceneBase_1.SceneBase));\nexports.Boot = Boot;\n\n\n//# sourceURL=webpack:///./src/scenes/Boot.ts?");

/***/ }),

/***/ "./src/scenes/GameScene.ts":
/*!*********************************!*\
  !*** ./src/scenes/GameScene.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GameScene = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar Player_1 = __webpack_require__(/*! ../Components/Player */ \"./src/Components/Player.ts\");\nvar MathUtils_1 = __webpack_require__(/*! ../lib/MathUtils */ \"./src/lib/MathUtils.ts\");\nvar BSPMazeGenerator_1 = __webpack_require__(/*! ../lib/BSPMazeGenerator */ \"./src/lib/BSPMazeGenerator.ts\");\nvar BlendModes = Phaser.BlendModes;\nvar WaterMazeTilesProcessor_1 = __webpack_require__(/*! ../lib/Maze/WaterMazeTilesProcessor */ \"./src/lib/Maze/WaterMazeTilesProcessor.ts\");\nvar StoneMazeTilesProcessor_1 = __webpack_require__(/*! ../lib/Maze/StoneMazeTilesProcessor */ \"./src/lib/Maze/StoneMazeTilesProcessor.ts\");\nvar BoatTrail_1 = __webpack_require__(/*! ../Components/BoatTrail */ \"./src/Components/BoatTrail.ts\");\nvar InGameSettingsButton_1 = __webpack_require__(/*! ../Components/InGameSettingsButton */ \"./src/Components/InGameSettingsButton.ts\");\nvar PopupManager_1 = __webpack_require__(/*! ../Components/Popup/PopupManager */ \"./src/Components/Popup/PopupManager.ts\");\nvar SettingsPopup_1 = __webpack_require__(/*! ../Components/Popup/Popups/SettingsPopup */ \"./src/Components/Popup/Popups/SettingsPopup.ts\");\nvar SceneBase_1 = __webpack_require__(/*! ./SceneBase */ \"./src/scenes/SceneBase.ts\");\nvar ParseToMultiLayerTilemap_1 = __webpack_require__(/*! ../lib/Tilemap/ParseToMultiLayerTilemap */ \"./src/lib/Tilemap/ParseToMultiLayerTilemap.ts\");\nvar LevelCompletedPopup_1 = __webpack_require__(/*! ../Components/Popup/Popups/LevelCompletedPopup */ \"./src/Components/Popup/Popups/LevelCompletedPopup.ts\");\nvar RedCarPlayer_1 = __webpack_require__(/*! ../Components/RedCarPlayer */ \"./src/Components/RedCarPlayer.ts\");\nvar NitroIndicatorOnPlayer_1 = __webpack_require__(/*! ../Components/NitroIndicatorOnPlayer */ \"./src/Components/NitroIndicatorOnPlayer.ts\");\nvar GameScene = /** @class */ (function (_super) {\n    __extends(GameScene, _super);\n    function GameScene() {\n        var _this = _super.call(this, {\n            active: false,\n            visible: false,\n            key: 'Game',\n        }) || this;\n        _this.MAP_WIDTH = 120;\n        _this.MAP_HEIGHT = 120;\n        _this.MINIMAP_SCALE = 1 / 24;\n        _this.STARS_ON_LEVEL = 10;\n        _this.NITROS_ON_LEVEL = 3;\n        _this.popupCount = 0;\n        return _this;\n    }\n    GameScene.prototype.init = function (props) {\n        var _a = props.level, level = _a === void 0 ? 0 : _a;\n        this.level = level;\n    };\n    GameScene.prototype.preload = function () {\n        this.load.setBaseURL('/PhaserGamePrototype/');\n        this.load.atlas('red_boat', 'assets/atlas/boatsSpriteListTransparent.png', 'assets/atlas/redBoatSpriteListConfig.json');\n        this.load.atlas('boat_trail', 'assets/atlas/boatsSpriteListTransparent.png', 'assets/atlas/boatTrailSpriteListConfig.json');\n        this.load.atlas('red_car', 'assets/atlas/carsSpriteListTransparent.png', 'assets/atlas/carsSpriteListConfig.json');\n        this.load.spritesheet('fullscreenSprite', 'assets/fullscreenSprite.png', { frameWidth: 32, frameHeight: 32 });\n        this.load.image('star', 'assets/star24.png');\n        this.load.image('nitro', 'assets/nitro24.png');\n        this.load.image('settingsIcon', 'assets/settingsIcon-24.png');\n        this.load.image('turnLeftArrow', 'assets/turnLeftArrow.png');\n        this.load.image('turnRightArrow', 'assets/turnRightArrow.png');\n        this.load.image('tilesExtruded', 'assets/tilemaps/WaterMazeTilesExtruded.png');\n        this.load.image('stoneTilesExtruded', 'assets/tilemaps/StoneMazeTilesExtruded.png');\n        this.load.tilemapTiledJSON('map', 'assets/tilemaps/WaterMazeMap.json');\n    };\n    GameScene.prototype.create = function () {\n        var _this = this;\n        var map;\n        var miniMap;\n        var tiles;\n        ///////////////// GENERATE MAP\n        var levelData = this.generateLevelData();\n        // Generator returns map with 0 on passed and 1 on blocked cell\n        // Lets place tiles with level sprite\n        var tiledLevelData = this.generateLevelTiles(levelData);\n        // format levelData as 2D array for collision layer\n        var chunk = this.MAP_WIDTH;\n        var collideLayerData = [];\n        for (var i = 0, j = levelData.length; i < j; i += chunk) {\n            collideLayerData.push(levelData.slice(i, i + chunk));\n        }\n        // format tiledLevelData as 2D array for visual tiles layers\n        var tiledLayerData = [];\n        for (var i = 0, j = tiledLevelData.length; i < j; i += chunk) {\n            tiledLayerData.push(tiledLevelData.slice(i, i + chunk));\n        }\n        // And pass layers to parser, to create multilayered map\n        map = ParseToMultiLayerTilemap_1.default(this, 'map', 24, 24, this.MAP_WIDTH, this.MAP_HEIGHT, [collideLayerData, tiledLayerData], false);\n        tiles = this.updateMapTiles(map);\n        this.collisionLayer = map.createStaticLayer(0, tiles, 0, 0);\n        this.tiledLayer = map.createStaticLayer(1, tiles, 0, 0);\n        // Set map to use '1' value of collision layer to calculate collisions\n        map.setCollision([1], true, false, this.collisionLayer);\n        miniMap = this.make.tilemap({ data: tiledLayerData, tileWidth: 24, tileHeight: 24 });\n        //////////////// PLACE STARS\n        this.stars = this.physics.add.group();\n        for (var i = 0; i < this.STARS_ON_LEVEL; i++) {\n            var tileX = void 0, tileY = void 0, placed = false;\n            do {\n                tileX = MathUtils_1.default.getRandomIntegerBetween(0, map.width - 1);\n                tileY = MathUtils_1.default.getRandomIntegerBetween(0, map.height - 1);\n                if (this.isFreeToPlaceWithNeighbors(tileX, tileY, map)) {\n                    placed = true;\n                    var coords = map.tileToWorldXY(tileX, tileY);\n                    this.stars.create(coords.x, coords.y, 'star');\n                }\n            } while (placed !== true);\n        }\n        console.log('STARS PLACED!');\n        //////////////// PLACE NITROS\n        this.nitros = this.physics.add.group();\n        for (var i = 0; i < this.NITROS_ON_LEVEL; i++) {\n            var tileX = void 0, tileY = void 0, placed = false;\n            do {\n                tileX = MathUtils_1.default.getRandomIntegerBetween(0, map.width - 1);\n                tileY = MathUtils_1.default.getRandomIntegerBetween(0, map.height - 1);\n                if (this.isFreeToPlaceWithNeighbors(tileX, tileY, map)) {\n                    placed = true;\n                    var coords = map.tileToWorldXY(tileX, tileY);\n                    var n = this.nitros.create(coords.x, coords.y, 'nitro');\n                    n.setTint(0xFF9933);\n                }\n            } while (placed !== true);\n        }\n        console.log('NITROS PLACED!');\n        //////////////// PLACE A PLAYER\n        var player, playerTileX, playerTileY, playerPlaced;\n        player = this.createPlayer();\n        do {\n            playerTileX = MathUtils_1.default.getRandomIntegerBetween(0, map.width - 1);\n            playerTileY = MathUtils_1.default.getRandomIntegerBetween(0, map.height - 1);\n            if (this.isFreeToPlaceWithNeighbors(playerTileX, playerTileY, map)) {\n                playerPlaced = true;\n                var coords = map.tileToWorldXY(playerTileX, playerTileY);\n                player.setPosition(coords.x, coords.y);\n            }\n        } while (playerPlaced !== true);\n        this.player = player;\n        this.playerBoatTrail = new BoatTrail_1.BoatTrail(this, player);\n        this.playerNitroIndicator = new NitroIndicatorOnPlayer_1.NitroIndicatorOnPlayer(this, player);\n        console.log('PLAYER PLACED!');\n        //////////////// SET OVERLAP BEHAVIOUR FOR STARS AND NITROS\n        //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function\n        this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);\n        // Checks to player overlaps nitro and set callback to get it\n        this.physics.add.overlap(this.player, this.nitros, this.collectNitro, null, this);\n        this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);\n        this.cameras.main.setRoundPixels(true);\n        this.cameras.main.startFollow(this.player, true);\n        ////////////////  SCORE\n        this.collectedStars = 0;\n        var textStyle = { fontSize: '28px', fill: '#000', fontFamily: 'Arial, sans-serif' };\n        this.scoreText = this.add.text(16, 16, \"\\u0421\\u043E\\u0431\\u0440\\u0430\\u043D\\u043E \\u0437\\u0432\\u0451\\u0437\\u0434: \" + this.collectedStars + \" \\u0438\\u0437 \" + this.STARS_ON_LEVEL, textStyle)\n            .setScrollFactor(0);\n        this.nitroText = this.add.text(this.gameWidth - 200, 16, \"\\u041D\\u0418\\u0422\\u0420\\u041E: \" + player.getNitroCount(), textStyle)\n            .setScrollFactor(0).setFontSize(20);\n        this.levelText = this.add.text(this.gameWidth - 70, this.gameHeight - 20, \"Level: \" + this.level, textStyle)\n            .setScrollFactor(0).setFontSize(12);\n        // Create minimap\n        this.createMiniMap(miniMap, tiles);\n        var gameScale = this.sys.game.scale;\n        // fullscreen toggle button\n        this.fullscreenButton = this.add.image(gameScale.width - 24, 16, 'fullscreenSprite', 0)\n            .setOrigin(1, 0)\n            .setScrollFactor(0)\n            .setInteractive({ useHandCursor: true })\n            .on('pointerup', function () {\n            if (this.scale.isFullscreen) {\n                this.fullscreenButton.setFrame(0);\n                this.scale.stopFullscreen();\n            }\n            else {\n                this.fullscreenButton.setFrame(1);\n                this.scale.startFullscreen();\n            }\n        }, this);\n        // Create settings icon\n        var settingsButton = new InGameSettingsButton_1.default(this, gameScale.width - 40, 75, 30, 30);\n        settingsButton.setScrollFactor(0);\n        settingsButton.on('pointerdown', function () {\n            PopupManager_1.default.createWindow(_this, new SettingsPopup_1.default());\n        });\n        this.game.events.on('GO_TO_MAIN_MENU', function () {\n            _this.scene.start('Hello');\n        });\n        this.game.events.on('LEVEL_COMPLETED', function () {\n            PopupManager_1.default.createWindow(_this, new LevelCompletedPopup_1.default());\n        });\n        this.game.events.on('GO_TO_NEXT_LEVEL', function () {\n            _this.cameras.main.fadeOut(500);\n            _this.time.addEvent({\n                delay: 500,\n                callback: function () {\n                    _this.scene.restart({ level: _this.level + 1 });\n                    _this.cameras.main.fadeIn(500);\n                }\n            });\n        });\n        // touch devices has 2 pointers but desktop has only one\n        if (this.input.manager.pointersTotal > 1) {\n            // Create touch controls for touch devices\n            this.createTouchControlZones();\n        }\n    };\n    GameScene.prototype.update = function (time, delta) {\n        this.player.update(time, delta);\n        this.collidePlayerWithWallCallback(time);\n        this.playerBoatTrail.update(time, delta);\n        this.playerNitroIndicator.update(time, delta);\n        // update minimap, draw objects by scaled coordinates\n        var miniPlayerX = this.player.body.position.x * this.MINIMAP_SCALE;\n        var miniPlayerY = this.player.body.position.y * this.MINIMAP_SCALE;\n        this.miniMapLocator.clear();\n        this.miniMapLocator.fillStyle(0xFF0000);\n        this.miniMapLocator.fillRect(miniPlayerX, miniPlayerY, 2, 2);\n        var player = this.player;\n        this.nitroText.setText(\"\\u041D\\u0418\\u0422\\u0420\\u041E: \" + player.getNitroCount());\n        // if fullscreen toggleoff by pressing Esc-button, redraw fullscreen icon\n        if (!this.scale.isFullscreen) {\n            this.fullscreenButton.setFrame(0);\n        }\n    };\n    GameScene.prototype.collectStar = function (player, star) {\n        star.disableBody(true, true);\n        //  Add and update the score\n        this.collectedStars += 1;\n        this.scoreText.setText(\"\\u0421\\u043E\\u0431\\u0440\\u0430\\u043D\\u043E \\u0437\\u0432\\u0451\\u0437\\u0434: \" + this.collectedStars + \" \\u0438\\u0437 \" + this.STARS_ON_LEVEL);\n        if (this.stars.countActive(true) === 0) {\n            console.log('ALL STARS COLLECTED!!!');\n            this.game.events.emit('LEVEL_COMPLETED');\n        }\n    };\n    GameScene.prototype.collectNitro = function (player, nitro) {\n        nitro.destroy();\n        this.player.addNitro();\n    };\n    /**\n     * Collide player with walls handler\n     * @param time\n     */\n    GameScene.prototype.collidePlayerWithWallCallback = function (time) {\n        time = time / 1000; // convert to seconds\n        var diff = time - GameScene.lastCollisionEffectTime;\n        this.physics.collide(this.player, this.collisionLayer, function (player, tile) {\n            if (diff > GameScene.playerNegativeEffectInterval) {\n                var playerInstance = player;\n                var speed = playerInstance.getSpeed();\n                playerInstance.setSpeed(speed > GameScene.minimalSpeedOnCollide ? speed / 2 : 0);\n                GameScene.lastCollisionEffectTime = time;\n            }\n        });\n    };\n    GameScene.prototype.createMiniMap = function (miniMap, tiles) {\n        var miniMapContainer = this.add.group();\n        // background\n        var miniMapBg = this.add.rectangle(70, this.gameWidth - 70, 130, 130, 0x666666, 0.6);\n        miniMapBg.setScrollFactor(0);\n        // SCALED tilemap on background, Scale = (1 / tileWidth)\n        this.miniLayer = miniMap.createStaticLayer(0, tiles, 10, this.gameHeight - 130);\n        this.miniLayer.setScale(this.MINIMAP_SCALE);\n        this.miniLayer.setScrollFactor(0);\n        this.miniLayer.setBlendMode(BlendModes.SCREEN);\n        // graphics to draw player and other objects!\n        this.miniMapLocator = this.add.graphics();\n        this.miniMapLocator.setScrollFactor(0);\n        this.miniMapLocator.setPosition(10, this.gameHeight - 130, 130, 130);\n        miniMapContainer.addMultiple([miniMapBg, this.miniLayer, this.miniMapLocator]);\n    };\n    /**\n     * Check tile on x,y and it neighbors. On all free - return true\n     * @param x\n     * @param y\n     * @param map\n     */\n    GameScene.prototype.isFreeToPlaceWithNeighbors = function (x, y, map) {\n        var tile = map.getTileAt(x, y, true, this.collisionLayer);\n        return tile.canCollide !== true\n            && map.getTileAt(x - 1, y - 1).canCollide !== true\n            && map.getTileAt(x, y - 1).canCollide !== true\n            && map.getTileAt(x + 1, y - 1).canCollide !== true\n            && map.getTileAt(x - 1, y).canCollide !== true\n            && map.getTileAt(x + 1, y).canCollide !== true\n            && map.getTileAt(x - 1, y + 1).canCollide !== true\n            && map.getTileAt(x, y + 1).canCollide !== true\n            && map.getTileAt(x + 1, y + 1).canCollide !== true;\n    };\n    GameScene.prototype.createTouchControlZones = function () {\n        var zoneOffsetX = 50;\n        var zoneOffsetY = 30;\n        var zonePadding = 20;\n        var zoneW = 60 + (2 * zonePadding);\n        var zoneH = 50 + (2 * zonePadding);\n        var leftZonePosX = zoneOffsetX - zonePadding;\n        var leftZonePosY = this.gameHeight - zoneOffsetY - zoneH;\n        var rightZonePosX = this.gameWidth - zoneOffsetX - zoneW;\n        var rightZonePosY = this.gameHeight - zoneOffsetY - zoneH;\n        var upZonePosX = zoneOffsetX - zonePadding;\n        var upZonePosY = this.gameHeight - 3 * (zoneOffsetY + zoneH);\n        var downZonePosX = zoneOffsetX - zonePadding;\n        var downZonePosY = this.gameHeight - 2 * (zoneOffsetY + zoneH);\n        var arrowW = 50;\n        var arrowH = 50;\n        // setOrigin(0) - значит позицию выставляем по левому верхнему углу\n        var leftArrowX = zoneOffsetX;\n        var leftArrowY = this.gameHeight - arrowH - zoneOffsetY - zonePadding;\n        var rightArrowX = this.gameWidth - arrowW - zoneOffsetX - zonePadding;\n        var rightArrowY = this.gameHeight - arrowH - zoneOffsetY - zonePadding;\n        var turnLeftArrow = this.add.image(leftArrowX, leftArrowY, 'turnLeftArrow')\n            .setOrigin(0, 0)\n            .setScrollFactor(0)\n            .setScale(0.5);\n        var turnRightArrow = this.add.image(rightArrowX, rightArrowY, 'turnRightArrow')\n            .setOrigin(0, 0)\n            .setScrollFactor(0)\n            .setScale(0.5);\n        // touch zones for turn left and right\n        var zoneLeft = this.add.zone(leftZonePosX, leftZonePosY, zoneW, zoneH)\n            .setOrigin(0, 0)\n            .setDepth(10)\n            .setScrollFactor(0);\n        var zoneLeftDebug = this.add.graphics({ x: 0, y: 0 })\n            .setPosition(leftZonePosX, leftZonePosY)\n            .fillStyle(0x000000, 0.5)\n            .fillRect(0, 0, zoneW, zoneH)\n            .setScrollFactor(0);\n        var zoneRight = this.add.zone(rightZonePosX, rightZonePosY, zoneW, zoneH)\n            .setOrigin(0, 0)\n            .setDepth(10)\n            .setScrollFactor(0);\n        var zoneRightDebug = this.add.graphics({ x: 0, y: 0 })\n            .setPosition(rightZonePosX, rightZonePosY)\n            .fillStyle(0x000000, 0.5)\n            .fillRect(0, 0, zoneW, zoneH)\n            .setScrollFactor(0);\n        var zoneUp = this.add.zone(upZonePosX, upZonePosY, zoneW, zoneH)\n            .setOrigin(0, 0)\n            .setDepth(10)\n            .setScrollFactor(0);\n        var zoneUpDebug = this.add.graphics({ x: 0, y: 0 })\n            .setPosition(upZonePosX, upZonePosY)\n            .fillStyle(0x000000, 0.5)\n            .fillRect(0, 0, zoneW, zoneH)\n            .setScrollFactor(0);\n        var textX = upZonePosX + zonePadding;\n        this.add.text(textX, upZonePosY + zonePadding, 'Speed')\n            .setScrollFactor(0)\n            .setColor('0x000000')\n            .setFontSize(18);\n        this.add.text(textX, upZonePosY + zonePadding + 20, 'Up')\n            .setScrollFactor(0)\n            .setColor('0x000000')\n            .setFontSize(18);\n        var zoneDown = this.add.zone(downZonePosX, downZonePosY, zoneW, zoneH)\n            .setOrigin(0, 0)\n            .setDepth(10)\n            .setScrollFactor(0);\n        var zoneDownDebug = this.add.graphics({ x: 0, y: 0 })\n            .setPosition(downZonePosX, downZonePosY)\n            .fillStyle(0x000000, 0.5)\n            .fillRect(0, 0, zoneW, zoneH)\n            .setScrollFactor(0);\n        this.add.text(textX, downZonePosY + zonePadding, 'Speed')\n            .setScrollFactor(0)\n            .setColor('0x000000')\n            .setFontSize(18);\n        this.add.text(textX, downZonePosY + zonePadding + 20, 'Down')\n            .setScrollFactor(0)\n            .setColor('0x000000')\n            .setFontSize(18);\n        var nitroPadding = 10;\n        var zoneNitroX = this.nitroText.x;\n        var zoneNitroY = this.nitroText.y;\n        var zoneNitroW = this.nitroText.width + (2 * nitroPadding);\n        var zoneNitroH = this.nitroText.height + (2 * nitroPadding);\n        var zoneNitro = this.add.zone(zoneNitroX - nitroPadding, zoneNitroY - nitroPadding, zoneNitroW, zoneNitroH)\n            .setOrigin(0, 0)\n            .setDepth(10)\n            .setScrollFactor(0);\n        var zoneNitroDebug = this.add.graphics({ x: 0, y: 0 })\n            .setPosition(zoneNitroX - nitroPadding, zoneNitroY - nitroPadding)\n            .fillStyle(0x000000, 0.5)\n            .fillRect(0, 0, zoneNitroW, zoneNitroH)\n            .setScrollFactor(0);\n        zoneLeft.setInteractive();\n        zoneLeft.on('pointerdown', this.holdLeft, this);\n        zoneLeft.on('pointerup', this.releaseLeft, this);\n        zoneLeft.on('pointerout', this.releaseLeft, this);\n        zoneRight.setInteractive();\n        zoneRight.on('pointerdown', this.holdRight, this);\n        zoneRight.on('pointerup', this.releaseRight, this);\n        zoneRight.on('pointerout', this.releaseRight, this);\n        zoneUp.setInteractive();\n        zoneUp.on('pointerdown', this.holdUp, this);\n        zoneUp.on('pointerup', this.releaseUp, this);\n        zoneUp.on('pointerout', this.releaseUp, this);\n        zoneDown.setInteractive();\n        zoneDown.on('pointerdown', this.holdDown, this);\n        zoneDown.on('pointerup', this.releaseDown, this);\n        zoneDown.on('pointerout', this.releaseDown, this);\n        zoneNitro.setInteractive();\n        zoneNitro.on('pointerdown', this.holdNitro, this);\n        zoneNitro.on('pointerup', this.releaseNitro, this);\n        zoneNitro.on('pointerout', this.releaseNitro, this);\n    };\n    GameScene.prototype.holdLeft = function () {\n        this.player.holdLeft();\n    };\n    GameScene.prototype.holdRight = function () {\n        this.player.holdRight();\n    };\n    GameScene.prototype.holdUp = function () {\n        this.player.holdUp();\n    };\n    GameScene.prototype.holdDown = function () {\n        this.player.holdDown();\n    };\n    GameScene.prototype.holdNitro = function () {\n        this.player.holdNitro();\n    };\n    GameScene.prototype.releaseLeft = function () {\n        this.player.releaseLeft();\n    };\n    GameScene.prototype.releaseRight = function () {\n        this.player.releaseRight();\n    };\n    GameScene.prototype.releaseUp = function () {\n        this.player.releaseUp();\n    };\n    GameScene.prototype.releaseDown = function () {\n        this.player.releaseDown();\n    };\n    GameScene.prototype.releaseNitro = function () {\n        this.player.releaseNitro();\n    };\n    GameScene.prototype.generateLevelData = function () {\n        var mapGenerator = new BSPMazeGenerator_1.default();\n        return mapGenerator.generateMap(this.MAP_WIDTH, this.MAP_HEIGHT, 2);\n    };\n    GameScene.prototype.generateLevelTiles = function (levelData) {\n        var tiledLevelData = [];\n        if (this.level % 2 === 0) {\n            tiledLevelData = WaterMazeTilesProcessor_1.default.placeTiles(levelData, this.MAP_WIDTH);\n        }\n        else {\n            tiledLevelData = StoneMazeTilesProcessor_1.default.placeTiles(levelData, this.MAP_WIDTH);\n        }\n        return tiledLevelData;\n    };\n    GameScene.prototype.updateMapTiles = function (map) {\n        var tiles;\n        if (this.level % 2 === 0) {\n            tiles = map.addTilesetImage('waterAndGrass', 'tilesExtruded', 26, 26, 1, 1, 1);\n        }\n        else {\n            tiles = map.addTilesetImage('stoneMaze', 'stoneTilesExtruded', 26, 26, 1, 1, 1);\n        }\n        return tiles;\n    };\n    GameScene.prototype.createPlayer = function () {\n        var player;\n        if (this.level % 2 === 0) {\n            player = new Player_1.Player(this, 0, 0);\n        }\n        else {\n            player = new RedCarPlayer_1.RedCarPlayer(this, 0, 0);\n        }\n        return player;\n    };\n    // Limits for player collisions handle\n    GameScene.minimalSpeedOnCollide = 25;\n    GameScene.playerNegativeEffectInterval = 0.2; // in seconds\n    GameScene.lastCollisionEffectTime = 0;\n    return GameScene;\n}(SceneBase_1.SceneBase));\nexports.GameScene = GameScene;\n\n\n//# sourceURL=webpack:///./src/scenes/GameScene.ts?");

/***/ }),

/***/ "./src/scenes/GeneratorScene.ts":
/*!**************************************!*\
  !*** ./src/scenes/GeneratorScene.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeneratorScene = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar TextButton_1 = __webpack_require__(/*! ../Components/TextButton */ \"./src/Components/TextButton.ts\");\nvar Graphics = Phaser.GameObjects.Graphics;\nvar KeyGenerator_1 = __webpack_require__(/*! ../lib/KeyGenerator */ \"./src/lib/KeyGenerator.ts\");\nvar BSPMazeGenerator_1 = __webpack_require__(/*! ../lib/BSPMazeGenerator */ \"./src/lib/BSPMazeGenerator.ts\");\nvar GeneratorScene = /** @class */ (function (_super) {\n    __extends(GeneratorScene, _super);\n    function GeneratorScene() {\n        var _this = this;\n        var sceneConfig = {\n            active: false,\n            visible: false,\n            key: 'Generator'\n        };\n        _this = _super.call(this, sceneConfig) || this;\n        _this.MAP_WIDTH = 120;\n        _this.MAP_HEIGHT = 120;\n        _this.zones = [];\n        _this.rooms = [];\n        _this.corridors = [];\n        _this.debugMarks = [];\n        return _this;\n    }\n    GeneratorScene.prototype.preload = function () {\n    };\n    GeneratorScene.prototype.create = function () {\n        var _this = this;\n        this.cameras.main.setBackgroundColor('#666666');\n        this.mapGenerator = new BSPMazeGenerator_1.default();\n        this.mapGenerator.generateMap(this.MAP_WIDTH, this.MAP_HEIGHT);\n        this.zones = this.mapGenerator.getZones();\n        this.rooms = this.mapGenerator.getRooms();\n        this.corridors = this.mapGenerator.getCorridors();\n        // отрисуем зоны, комнаты из коридоры\n        this.drawMap();\n        // КНОПОЧКИ\n        // кнопочка перегенерации карты\n        this.generateButton = new TextButton_1.default(this, 5, 5, 'Generate');\n        this.generateButton.setFontSize(12).setDepth(10);\n        this.generateButton.on('pointerdown', function () { return _this.restartScene(); });\n        this.add.existing(this.generateButton);\n        // кнопочка скрыть/показать метки комнат и корридоров\n        this.showMarksButton = new TextButton_1.default(this, 70, 5, 'Show marks');\n        this.showMarksButton.setFontSize(12).setDepth(10);\n        this.showMarksButton.on('pointerdown', function () { return _this.toggleMarks(); });\n        this.add.existing(this.showMarksButton);\n        // кнопочка скачать скриншот\n        this.getScreenshotButton = new TextButton_1.default(this, 150, 5, 'Screenshot');\n        this.getScreenshotButton.setFontSize(12).setDepth(10);\n        this.getScreenshotButton.on('pointerdown', function () {\n            _this.game.renderer.snapshot(function (image) {\n                // console.log(image);\n                GeneratorScene.exportCanvasAsPNG('snapshot', image.src);\n            });\n        });\n        this.add.existing(this.getScreenshotButton);\n        // кнопочка запуска клеточного автомата\n        this.nextIterationButton = new TextButton_1.default(this, 250, 5, 'Iterate Map Filter');\n        this.nextIterationButton.setFontSize(12).setDepth(10);\n        this.nextIterationButton.on('pointerdown', function () {\n            _this.nextCellularAutomateIteration();\n        });\n        this.add.existing(this.nextIterationButton);\n        // кнопочка для получения дампа карты в textarea\n        var getDumpButton = new TextButton_1.default(this, 400, 5, 'Get dump')\n            .setFontSize(12)\n            .on('pointerdown', function () {\n            _this.getMapDump();\n        });\n        this.add.existing(getDumpButton);\n        // кнопочка для возвращения в основное меню\n        var returnToMainMenuButton = new TextButton_1.default(this, this.cameras.main.width - 115, 5, 'Return to Menu')\n            .setFontSize(12)\n            .on('pointerdown', function () {\n            _this.scene.start('Hello');\n        });\n        this.add.existing(returnToMainMenuButton);\n    };\n    GeneratorScene.prototype.restartScene = function () {\n        this.zones = [];\n        this.rooms = [];\n        this.corridors = [];\n        KeyGenerator_1.default.resetAll();\n        this.mapGenerator = null;\n        this.graphicsForMap = null;\n        this.scene.restart();\n    };\n    GeneratorScene.prototype.toggleMarks = function () {\n        var _this = this;\n        this.isDebugMarksVisible = !this.isDebugMarksVisible;\n        this.debugMarks.forEach(function (mark) {\n            mark.setVisible(_this.isDebugMarksVisible);\n        });\n    };\n    GeneratorScene.prototype.update = function (time, delta) {\n    };\n    GeneratorScene.exportCanvasAsPNG = function (fileName, dataUrl) {\n        var MIME_TYPE = \"image/png\";\n        var imgURL = dataUrl;\n        var dlLink = document.createElement('a');\n        dlLink.download = fileName;\n        dlLink.href = imgURL;\n        dlLink.dataset.downloadurl = [MIME_TYPE, dlLink.download, dlLink.href].join(':');\n        document.body.appendChild(dlLink);\n        dlLink.click();\n        document.body.removeChild(dlLink);\n    };\n    /**\n     * Положение карты рисуем по центру холста, поэтому придётся посчитать отступ\n     * от краёв холста по X и Y, исходя из размера карты и ширины камеры\n     */\n    GeneratorScene.prototype.getMapOffsetX = function () {\n        return (this.cameras.main.width / 2) - (this.MAP_WIDTH / 2);\n    };\n    GeneratorScene.prototype.getMapOffsetY = function () {\n        return (this.cameras.main.height / 2) - (this.MAP_HEIGHT / 2);\n    };\n    GeneratorScene.prototype.drawMap = function () {\n        var _this = this;\n        // NOTE!\n        // Рисуем карту по центру холста\n        var mapOffsetX = this.getMapOffsetX();\n        var mapOffsetY = this.getMapOffsetY();\n        this.add.rectangle(this.cameras.main.width / 2, this.cameras.main.height / 2, this.MAP_WIDTH, this.MAP_HEIGHT, 0x000000);\n        // и теперь для всех комнат и коридоров для дебага можно отрисовать их метки\n        // поверх уже нарисованной карты\n        // ЗОНЫ\n        // this.zones.forEach((tree: Tree) => {\n        //     // отрисуем зону\n        //     this.add.rectangle(\n        //         mapOffsetX + tree.x + (tree.width/2), mapOffsetY + tree.y + (tree.height/2),\n        //         tree.width - 2, tree.height - 2,\n        //         0x0000FF,\n        //         .2\n        //     );\n        //     this.add.text(\n        //         tree.x, tree.y,\n        //         `${tree.id}`\n        //     ).setColor('yellow').setFontSize(10);\n        // });\n        // КОМНАТЫ\n        this.rooms.forEach(function (room) {\n            // при отрисовке на поле, позиционирование происходит по центру спрайта/фигуры\n            _this.add.rectangle(mapOffsetX + room.x + (room.width / 2), mapOffsetY + room.y + (room.height / 2), room.width, room.height, 0xFFFFFF);\n            var mark = _this.add.text(mapOffsetX + room.x, mapOffsetY + room.y, \"\" + room.id).setColor('green').setFontSize(10).setVisible(_this.isDebugMarksVisible).setDepth(10);\n            _this.debugMarks.push(mark);\n        });\n        // КОРИДОРЫ\n        this.corridors.forEach(function (corridor) {\n            _this.add.rectangle(mapOffsetX + corridor.x + (corridor.width / 2), mapOffsetY + corridor.y + (corridor.height / 2), corridor.width, corridor.height, 0xFFFFFF);\n            var mark = _this.add.text(mapOffsetX + corridor.x + corridor.width / 2, mapOffsetY + corridor.y + corridor.height / 2, \"\" + corridor.id).setColor('black').setBackgroundColor('yellow').setFontSize(10).setVisible(_this.isDebugMarksVisible).setDepth(10);\n            _this.debugMarks.push(mark);\n        });\n    };\n    /**\n     * Запускаем итерации клеточного автомата по нашей карте\n     */\n    GeneratorScene.prototype.nextCellularAutomateIteration = function () {\n        if (this.graphicsForMap instanceof Graphics) {\n            this.graphicsForMap.clear();\n            this.mapGenerator.runFilterIteration();\n            this.graphicsForMap.translateCanvas(this.getMapOffsetX(), this.getMapOffsetY());\n            this.mapGenerator.renderMap(this.graphicsForMap);\n        }\n        else {\n            this.graphicsForMap = this.add.graphics();\n            this.graphicsForMap.translateCanvas(this.getMapOffsetX(), this.getMapOffsetY());\n            this.mapGenerator.renderMap(this.graphicsForMap);\n        }\n    };\n    GeneratorScene.prototype.getMapDump = function () {\n        var map = this.mapGenerator.getMap();\n        console.log('MAP DUMP: ', map.slice(0, 10));\n        var textarea = document.getElementById('textarea');\n        if (!textarea) {\n            textarea = document.createElement('textarea');\n            textarea.setAttribute('id', 'textarea');\n        }\n        textarea.cols = 150;\n        textarea.rows = 10;\n        textarea.value = map.toString();\n        document.body.append(textarea);\n    };\n    return GeneratorScene;\n}(Phaser.Scene));\nexports.GeneratorScene = GeneratorScene;\n\n\n//# sourceURL=webpack:///./src/scenes/GeneratorScene.ts?");

/***/ }),

/***/ "./src/scenes/HelloScene.ts":
/*!**********************************!*\
  !*** ./src/scenes/HelloScene.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HelloScene = void 0;\nvar GameMenuButton_1 = __webpack_require__(/*! ../Components/GameMenuButton */ \"./src/Components/GameMenuButton.ts\");\nvar SceneBase_1 = __webpack_require__(/*! ./SceneBase */ \"./src/scenes/SceneBase.ts\");\nvar HelloScene = /** @class */ (function (_super) {\n    __extends(HelloScene, _super);\n    function HelloScene() {\n        var _this = this;\n        console.log(\"HelloScene\");\n        var sceneConfig = {\n            active: false,\n            visible: false,\n            key: 'Hello',\n        };\n        _this = _super.call(this, sceneConfig) || this;\n        return _this;\n    }\n    HelloScene.prototype.preload = function () {\n    };\n    HelloScene.prototype.create = function () {\n        var _this = this;\n        var centerX = this.gameWidth / 2;\n        var centerY = this.gameHeight / 2;\n        var header = this.add.text(centerX, 20, 'Выбери что будешь делать');\n        header.setFontStyle('bold')\n            .setFontSize(16)\n            .setX(centerX - Math.round(header.width / 2));\n        // КНОПОЧКИ\n        // 1. Игра: найди и собери\n        var goSearchBoxGame = new GameMenuButton_1.default(this, 150, 100, 100, 100, 'Искать клады');\n        goSearchBoxGame.on('pointerdown', function () {\n            _this.scene.start('Game');\n        });\n        this.add.existing(goSearchBoxGame);\n        // 2. Генератор лабиринтов\n        var goMazeGenerator = new GameMenuButton_1.default(this, 150, 300, 100, 100, \"Генератор \\nлабиринтов\");\n        goMazeGenerator.on('pointerdown', function () {\n            _this.scene.start('Generator');\n        });\n        this.add.existing(goMazeGenerator);\n    };\n    HelloScene.prototype.update = function (time, delta) {\n    };\n    return HelloScene;\n}(SceneBase_1.SceneBase));\nexports.HelloScene = HelloScene;\n\n\n//# sourceURL=webpack:///./src/scenes/HelloScene.ts?");

/***/ }),

/***/ "./src/scenes/Preloader.ts":
/*!*********************************!*\
  !*** ./src/scenes/Preloader.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Preloader = void 0;\nvar SceneBase_1 = __webpack_require__(/*! ./SceneBase */ \"./src/scenes/SceneBase.ts\");\nvar Preloader = /** @class */ (function (_super) {\n    __extends(Preloader, _super);\n    function Preloader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // -------------------------------------------------------------------------\n    Preloader.prototype.create = function () {\n        console.log(\"Preloader\");\n        this.scene.start(\"Hello\");\n    };\n    return Preloader;\n}(SceneBase_1.SceneBase));\nexports.Preloader = Preloader;\n\n\n//# sourceURL=webpack:///./src/scenes/Preloader.ts?");

/***/ }),

/***/ "./src/scenes/SceneBase.ts":
/*!*********************************!*\
  !*** ./src/scenes/SceneBase.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SceneBase = void 0;\nvar SceneBase = /** @class */ (function (_super) {\n    __extends(SceneBase, _super);\n    function SceneBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(SceneBase.prototype, \"gameWidth\", {\n        // --------------------------------------------------------------------\n        get: function () {\n            return this.sys.game.config.width;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SceneBase.prototype, \"gameHeight\", {\n        // --------------------------------------------------------------------\n        get: function () {\n            return this.sys.game.config.height;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // --------------------------------------------------------------------\n    SceneBase.prototype.setView = function () {\n        // focus on center\n        this.cameras.main.centerOn(0, 0);\n    };\n    return SceneBase;\n}(Phaser.Scene));\nexports.SceneBase = SceneBase;\n\n\n//# sourceURL=webpack:///./src/scenes/SceneBase.ts?");

/***/ })

/******/ });