/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"app": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./src/main.ts","vendors"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Components/Corridor.ts":
/*!************************************!*\
  !*** ./src/Components/Corridor.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Corridor = /** @class */ (function () {\n    function Corridor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    return Corridor;\n}());\nexports.default = Corridor;\n\n\n//# sourceURL=webpack:///./src/Components/Corridor.ts?");

/***/ }),

/***/ "./src/Components/Room.ts":
/*!********************************!*\
  !*** ./src/Components/Room.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Room = /** @class */ (function () {\n    function Room(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    return Room;\n}());\nexports.default = Room;\n\n\n//# sourceURL=webpack:///./src/Components/Room.ts?");

/***/ }),

/***/ "./src/Components/SelectGameButton.ts":
/*!********************************************!*\
  !*** ./src/Components/SelectGameButton.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar SelectGameButton = /** @class */ (function (_super) {\n    __extends(SelectGameButton, _super);\n    function SelectGameButton(scene, x, y, width, height, text) {\n        var _this = _super.call(this, scene, x, y) || this;\n        _this.defaultBgColor = 0xFFFF99;\n        _this.hoverBgColor = 0x99FFFF;\n        _this.defaultTextColor = '#fff';\n        _this.hoverTextColor = '#0ff';\n        _this.activeTextColor = '#ff0';\n        _this.buttonBg = scene.add.rectangle(0, 0, width, height, _this.defaultBgColor)\n            .setStrokeStyle(5, 0x9FF);\n        _this.buttonText = scene.add.text(0, 0, text)\n            .setColor('#000000')\n            .setFontSize(12)\n            .setFontStyle('bold');\n        // А теперь отцентруем текст на кнопке, с учётом его получившейся ширины\n        var textCenter = _this.buttonText.getCenter();\n        _this.buttonText.setX(Math.round(-textCenter.x));\n        _this.buttonText.setY(Math.round(-textCenter.y));\n        _this.add([_this.buttonBg, _this.buttonText])\n            .setSize(width, height)\n            .setInteractive({ useHandCursor: true });\n        _this.on('pointerover', function () { return _this.buttonHoverState(); })\n            .on('pointerout', function () { return _this.buttonRestState(); });\n        scene.add.existing(_this);\n        return _this;\n    }\n    SelectGameButton.prototype.buttonHoverState = function () {\n        this.buttonBg.setFillStyle(this.hoverBgColor);\n    };\n    SelectGameButton.prototype.buttonRestState = function () {\n        this.buttonBg.setFillStyle(this.defaultBgColor);\n    };\n    return SelectGameButton;\n}(Phaser.GameObjects.Container));\nexports.default = SelectGameButton;\n\n\n//# sourceURL=webpack:///./src/Components/SelectGameButton.ts?");

/***/ }),

/***/ "./src/Components/TextButton.ts":
/*!**************************************!*\
  !*** ./src/Components/TextButton.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar TextButton = /** @class */ (function (_super) {\n    __extends(TextButton, _super);\n    function TextButton(scene, x, y, text, style) {\n        var _this = _super.call(this, scene, x, y, text, style) || this;\n        _this.defaultTextColor = '#fff';\n        _this.hoverTextColor = '#0ff';\n        _this.activeTextColor = '#ff0';\n        _this.setFontSize(10);\n        _this.setShadow(0, 0, 'black', 5);\n        _this.setStyle({ fill: _this.defaultTextColor });\n        _this.setInteractive({ useHandCursor: true })\n            .on('pointerover', function () { return _this.buttonHoverState(); })\n            .on('pointerout', function () { return _this.buttonRestState(); })\n            .on('pointerdown', function () { return _this.buttonActiveState(); })\n            .on('pointerup', function () { return _this.buttonHoverState(); });\n        return _this;\n    }\n    TextButton.prototype.buttonHoverState = function () {\n        this.setStyle({ fill: this.hoverTextColor });\n    };\n    TextButton.prototype.buttonRestState = function () {\n        this.setStyle({ fill: this.defaultTextColor });\n    };\n    TextButton.prototype.buttonActiveState = function () {\n        this.setStyle({ fill: this.activeTextColor });\n    };\n    return TextButton;\n}(Phaser.GameObjects.Text));\nexports.default = TextButton;\n\n\n//# sourceURL=webpack:///./src/Components/TextButton.ts?");

/***/ }),

/***/ "./src/Components/Tree.ts":
/*!********************************!*\
  !*** ./src/Components/Tree.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Room_1 = __webpack_require__(/*! ./Room */ \"./src/Components/Room.ts\");\nvar Tree = /** @class */ (function () {\n    function Tree(width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = 0;\n        this.y = 0;\n    }\n    /**\n     * Берёт из узла или собственную комнату или одну из комнат его дочерних узлов\n     */\n    Tree.prototype.getRoom = function () {\n        if (this.room instanceof Room_1.default) {\n            return this.room;\n        }\n        var leftRoom, rightRoom;\n        if (this.left instanceof Tree) {\n            leftRoom = this.left.getRoom();\n        }\n        if (this.left instanceof Tree) {\n            rightRoom = this.right.getRoom();\n        }\n        if (leftRoom === null && rightRoom === null) {\n            return null;\n        }\n        if (leftRoom !== null || rightRoom !== null) {\n            return leftRoom === null ? rightRoom : leftRoom;\n        }\n        // если есть обе комнаты, всегда возвращаем левую\n        return leftRoom;\n    };\n    return Tree;\n}());\nexports.default = Tree;\n\n\n//# sourceURL=webpack:///./src/Components/Tree.ts?");

/***/ }),

/***/ "./src/Player.ts":
/*!***********************!*\
  !*** ./src/Player.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Player = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar Player = /** @class */ (function (_super) {\n    __extends(Player, _super);\n    function Player(scene, x, y) {\n        var _this = _super.call(this, scene, x, y, 'red_boat') || this;\n        _this.playerSpriteRotateSize = 11.25; // 11.25 градусов на спрайт\n        _this.direction = 0;\n        _this.speed = 0;\n        _this.SPEED_LIMIT = 150;\n        _this.BACKWARD_SPEED_LIMIT = -50;\n        _this.ACCELERATION = 30; // m/sec^2\n        _this.DECELERATION = 50; // m/sec^2\n        _this.ROTATE_SPEED = 90; // Degrees per second\n        // добавляем в сцену чтобы спрайт был видим\n        _this.scene.add.existing(_this);\n        // добавляем в физику, чтобы учавствовать в обсчитывании столкновений\n        _this.scene.physics.add.existing(_this);\n        return _this;\n    }\n    Player.prototype.getPlayerSpriteByDirection = function (player, directionInDeg) {\n        var halfStep = this.playerSpriteRotateSize / 2;\n        // 5.625 - половина от шага поворота. Спрайт смотрит в определённый угол и плюс-минус половина шага.\n        var index = 0;\n        if ((directionInDeg > (360 - halfStep)) || directionInDeg < halfStep) {\n            index = 0;\n        }\n        else if ((directionInDeg > (11.25 - halfStep)) && (directionInDeg < (11.25 + halfStep))) {\n            index = 1;\n        }\n        else if (directionInDeg > (22.5 - halfStep) && directionInDeg < (22.5 + halfStep)) {\n            index = 2;\n        }\n        else if (directionInDeg > (33.75 - halfStep) && directionInDeg < (33.75 + halfStep)) {\n            index = 3;\n        }\n        else if (directionInDeg > (45 - halfStep) && directionInDeg < (45 + halfStep)) {\n            index = 4;\n        }\n        else if (directionInDeg > (56.25 - halfStep) && directionInDeg < (56.25 + halfStep)) {\n            index = 5;\n        }\n        else if (directionInDeg > (67.5 - halfStep) && directionInDeg < (67.5 + halfStep)) {\n            index = 6;\n        }\n        else if (directionInDeg > (78.75 - halfStep) && directionInDeg < (78.75 + halfStep)) {\n            index = 7;\n        }\n        else if (directionInDeg > (90 - halfStep) && directionInDeg < (90 + halfStep)) {\n            index = 8;\n        }\n        else if (directionInDeg > (101.25 - halfStep) && directionInDeg < (101.25 + halfStep)) {\n            index = 9;\n        }\n        else if (directionInDeg > (112.5 - halfStep) && directionInDeg < (112.5 + halfStep)) {\n            index = 10;\n        }\n        else if (directionInDeg > (123.75 - halfStep) && directionInDeg < (123.75 + halfStep)) {\n            index = 11;\n        }\n        else if (directionInDeg > (135 - halfStep) && directionInDeg < (135 + halfStep)) {\n            index = 12;\n        }\n        else if (directionInDeg > (146.25 - halfStep) && directionInDeg < (146.25 + halfStep)) {\n            index = 13;\n        }\n        else if (directionInDeg > (157.5 - halfStep) && directionInDeg < (157.5 + halfStep)) {\n            index = 14;\n        }\n        else if (directionInDeg > (168.75 - halfStep) && directionInDeg < (168.75 + halfStep)) {\n            index = 15;\n        }\n        else if (directionInDeg > (180 - halfStep) && directionInDeg < (180 + halfStep)) {\n            index = 16;\n        }\n        else if (directionInDeg > (191.25 - halfStep) && directionInDeg < (191.25 + halfStep)) {\n            index = 17;\n        }\n        else if (directionInDeg > (202.5 - halfStep) && directionInDeg < (202.5 + halfStep)) {\n            index = 18;\n        }\n        else if (directionInDeg > (213.75 - halfStep) && directionInDeg < (213.75 + halfStep)) {\n            index = 19;\n        }\n        else if (directionInDeg > (225 - halfStep) && directionInDeg < (225 + halfStep)) {\n            index = 20;\n        }\n        else if (directionInDeg > (236.25 - halfStep) && directionInDeg < (236.25 + halfStep)) {\n            index = 21;\n        }\n        else if (directionInDeg > (247.5 - halfStep) && directionInDeg < (247.5 + halfStep)) {\n            index = 22;\n        }\n        else if (directionInDeg > (258.75 - halfStep) && directionInDeg < (258.75 + halfStep)) {\n            index = 23;\n        }\n        else if (directionInDeg > (270 - halfStep) && directionInDeg < (270 + halfStep)) {\n            index = 24;\n        }\n        else if (directionInDeg > (281.25 - halfStep) && directionInDeg < (281.25 + halfStep)) {\n            index = 25;\n        }\n        else if (directionInDeg > (292.5 - halfStep) && directionInDeg < (292.5 + halfStep)) {\n            index = 26;\n        }\n        else if (directionInDeg > (303.75 - halfStep) && directionInDeg < (303.75 + halfStep)) {\n            index = 27;\n        }\n        else if (directionInDeg > (315 - halfStep) && directionInDeg < (315 + halfStep)) {\n            index = 28;\n        }\n        else if (directionInDeg > (326.25 - halfStep) && directionInDeg < (326.25 + halfStep)) {\n            index = 29;\n        }\n        else if (directionInDeg > (337.5 - halfStep) && directionInDeg < (337.5 + halfStep)) {\n            index = 30;\n        }\n        else if (directionInDeg > (348.75 - halfStep) && directionInDeg < (348.75 + halfStep)) {\n            index = 31;\n        }\n        var num = index;\n        if (index > 16) {\n            num = 31 - index;\n            return { name: 'red_boat_' + num, flipX: true };\n        }\n        return { name: 'red_boat_' + num, flipX: false };\n    };\n    ;\n    Player.prototype.update = function (time, delta) {\n        var tDiff = delta / 1000;\n        var cursors = this.scene.input.keyboard.createCursorKeys();\n        if (cursors.left.isDown) {\n            this.direction -= (this.ROTATE_SPEED * tDiff);\n            if (this.direction < 0) {\n                this.direction = 360 - (this.direction);\n            }\n        }\n        else if (cursors.right.isDown) {\n            this.direction += (this.ROTATE_SPEED * tDiff);\n            if (this.direction > 360) {\n                this.direction = this.direction - 360;\n            }\n        }\n        if (cursors.up.isDown) {\n            this.speed += (this.ACCELERATION * tDiff);\n            if (this.speed > this.SPEED_LIMIT) {\n                this.speed = this.SPEED_LIMIT;\n            }\n        }\n        else if (cursors.down.isDown) {\n            this.speed -= (this.DECELERATION * tDiff);\n            if (this.speed < this.BACKWARD_SPEED_LIMIT) {\n                this.speed = this.BACKWARD_SPEED_LIMIT;\n            }\n        }\n        if (cursors.space.isDown) {\n            if (this.speed > 0) {\n                this.speed -= (this.DECELERATION * tDiff);\n                if (this.speed < 0) {\n                    this.speed = 0;\n                }\n            }\n            else if (this.speed < 0) {\n                this.speed += (this.DECELERATION * tDiff);\n                if (this.speed > 0) {\n                    this.speed = 0;\n                }\n            }\n        }\n        // после всех изменений проапдейтим горизонтальную и вертикальную скорости\n        this.updateVelocities();\n        // взять нужный спрайт, подставить в отображение\n        var config = this.getPlayerSpriteByDirection(this, this.direction);\n        // обновляем отображаемый фрейм спрайта\n        var frame = this.setFrame(config.name);\n        this.setBodySize(frame.width, frame.height);\n        this.flipX = config.flipX || false;\n    };\n    Player.prototype.updateVelocities = function () {\n        var directionInRad = this.direction * Math.PI / 180;\n        this.setVelocityX(this.speed * Math.sin(directionInRad));\n        this.setVelocityY(-1 * this.speed * Math.cos(directionInRad));\n    };\n    return Player;\n}(Phaser.Physics.Arcade.Sprite));\nexports.Player = Player;\n\n\n//# sourceURL=webpack:///./src/Player.ts?");

/***/ }),

/***/ "./src/lib/BSPMazeGenerator.ts":
/*!*************************************!*\
  !*** ./src/lib/BSPMazeGenerator.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Tree_1 = __webpack_require__(/*! ../Components/Tree */ \"./src/Components/Tree.ts\");\nvar Room_1 = __webpack_require__(/*! ../Components/Room */ \"./src/Components/Room.ts\");\nvar Corridor_1 = __webpack_require__(/*! ../Components/Corridor */ \"./src/Components/Corridor.ts\");\nvar KeyGenerator_1 = __webpack_require__(/*! ./KeyGenerator */ \"./src/lib/KeyGenerator.ts\");\nvar CellularAutomate_1 = __webpack_require__(/*! ./CellularAutomate */ \"./src/lib/CellularAutomate.ts\");\nvar MathUtils_1 = __webpack_require__(/*! ./MathUtils */ \"./src/lib/MathUtils.ts\");\nvar BSPMazeGenerator = /** @class */ (function () {\n    function BSPMazeGenerator() {\n        this.zones = [];\n        this.rooms = [];\n        this.corridors = [];\n        this.debugMarks = [];\n        this.MAX = 50; // максимальный размер зоны - если больше, то можно делить\n        // минимальный размер комнаты удобно делать больше 50%. Тогда при соединении\n        // всегда рисуем коридор посередине и попадаем куда надо :)\n        this.MIN_ROOM_SIZE = 70; // в процентах от размера зоны\n        this.MIN_ROOM_MARGIN = 5; // комната не должна быть к краю зоны ближе чем это значение\n        this.CORRIDOR_WIDTH = 4;\n        this.SPLIT_FROM = 20; // ограничение по разделению на зоны, не ближе чем 30% от одной стены\n        this.SPLIT_TO = 80; // ограничение по разделению на зоны, не ближе чем 70% от другой стены\n    }\n    BSPMazeGenerator.prototype.getZones = function () {\n        return this.zones;\n    };\n    BSPMazeGenerator.prototype.getRooms = function () {\n        return this.rooms;\n    };\n    BSPMazeGenerator.prototype.getCorridors = function () {\n        return this.corridors;\n    };\n    BSPMazeGenerator.prototype.generateMap = function (mapWidth, mapHeight, smoothIterations) {\n        var startTree = new Tree_1.default(mapWidth, mapHeight);\n        startTree.x = 0;\n        startTree.y = 0;\n        startTree.id = 'T' + KeyGenerator_1.default.getNextKey();\n        this.zones.push(startTree);\n        // сгенерируем дерево\n        var tree = this.generate(startTree);\n        this.createRooms(tree);\n        // Построим карту с помощью клеточного автомата\n        this.cellularAutomate = new CellularAutomate_1.default(mapWidth, mapHeight, this.rooms, this.corridors);\n        this.cellularAutomate.initializeMap();\n        // если затребован фильтр для сглаживания границ - используем его\n        if (smoothIterations > 0) {\n            this.cellularAutomate.run(smoothIterations);\n        }\n        return this.cellularAutomate.getMap();\n    };\n    BSPMazeGenerator.prototype.getMap = function () {\n        return this.cellularAutomate.getMap();\n    };\n    /**\n     * Прогоняет по карте одну итерацию клеточного автомата\n     */\n    BSPMazeGenerator.prototype.runFilterIteration = function () {\n        this.cellularAutomate.run();\n    };\n    /**\n     * Отрисовывает карту в переданный объект graphics\n     * @param graphics\n     */\n    BSPMazeGenerator.prototype.renderMap = function (graphics) {\n        this.cellularAutomate.renderMap(graphics);\n    };\n    BSPMazeGenerator.prototype.getSplitSizes = function (size) {\n        var splitMin = size / 100 * this.SPLIT_FROM;\n        var splitMax = size / 100 * this.SPLIT_TO;\n        var point = MathUtils_1.default.getRandomIntegerBetween(splitMin, splitMax);\n        return [point, size - point];\n    };\n    BSPMazeGenerator.prototype.generate = function (tree) {\n        var _a, _b;\n        var splitType;\n        // если не делится, просто возвращаемся сразу\n        if (tree.width < this.MAX && tree.height < this.MAX) {\n            return tree;\n        }\n        if (tree.width > this.MAX && tree.height > this.MAX) {\n            // get random split type\n            var array = ['vertical', 'horizontal'];\n            splitType = array[Math.floor(Math.random() * array.length)];\n        }\n        else {\n            splitType = tree.width > this.MAX ? 'vertical' : 'horizontal';\n        }\n        var leftSize, rightSize;\n        var leftTree, rightTree;\n        if (splitType === 'vertical') {\n            if (tree.width > this.MAX) {\n                _a = this.getSplitSizes(tree.width), leftSize = _a[0], rightSize = _a[1];\n                leftTree = new Tree_1.default(leftSize, tree.height);\n                rightTree = new Tree_1.default(rightSize, tree.height);\n                leftTree.x = tree.x;\n                leftTree.y = tree.y;\n                rightTree.x = tree.x + leftSize;\n                rightTree.y = tree.y;\n            }\n        }\n        else {\n            if (tree.height > this.MAX) {\n                _b = this.getSplitSizes(tree.height), leftSize = _b[0], rightSize = _b[1];\n                leftTree = new Tree_1.default(tree.width, leftSize);\n                rightTree = new Tree_1.default(tree.width, rightSize);\n                leftTree.x = tree.x;\n                leftTree.y = tree.y;\n                rightTree.x = tree.x;\n                rightTree.y = tree.y + leftSize;\n            }\n        }\n        if (leftTree instanceof Tree_1.default) {\n            leftTree.id = 'T' + KeyGenerator_1.default.getNextKey();\n            this.zones.push(leftTree);\n            tree.left = this.generate(leftTree);\n        }\n        if (rightTree instanceof Tree_1.default) {\n            rightTree.id = 'T' + KeyGenerator_1.default.getNextKey();\n            this.zones.push(rightTree);\n            tree.right = this.generate(rightTree);\n        }\n        return tree;\n    };\n    // Создаём комнаты в зонах\n    BSPMazeGenerator.prototype.createRooms = function (tree) {\n        if (!(tree.left instanceof Tree_1.default && tree.right instanceof Tree_1.default)) {\n            // отрисуем \"комнату\" в зоне. Комнаты должны быть меньше от 10 до 30% чем ячейка\n            // минимальный размер комнаты - 60% от зоны\n            var minWidth = tree.width / 100 * this.MIN_ROOM_SIZE;\n            var minHeight = tree.height / 100 * this.MIN_ROOM_SIZE;\n            var roomOffsetX = MathUtils_1.default.getRandomIntegerBetween(this.MIN_ROOM_MARGIN, tree.width - minWidth);\n            var roomOffsetY = MathUtils_1.default.getRandomIntegerBetween(this.MIN_ROOM_MARGIN, tree.height - minHeight);\n            var roomWidth = MathUtils_1.default.getRandomIntegerBetween(minWidth, tree.width - roomOffsetX - this.MIN_ROOM_MARGIN);\n            var roomHeight = MathUtils_1.default.getRandomIntegerBetween(minHeight, tree.height - roomOffsetY - this.MIN_ROOM_MARGIN);\n            // создаём комнату с реальными x и y на холсте\n            var roomX = tree.x + roomOffsetX;\n            var roomY = tree.y + roomOffsetY;\n            tree.room = new Room_1.default(roomX, roomY, roomWidth, roomHeight);\n            tree.room.tree = tree;\n            tree.room.id = KeyGenerator_1.default.getNextKey('R');\n            this.rooms.push(tree.room);\n        }\n        if (tree.left instanceof Tree_1.default && tree.right instanceof Tree_1.default) {\n            this.createRooms(tree.left);\n            this.createRooms(tree.right);\n            var corridor = this.getCorridor(tree.left, tree.right);\n            if (corridor instanceof Corridor_1.default) {\n                this.corridors.push(corridor);\n            }\n        }\n    };\n    BSPMazeGenerator.prototype.getCorridor = function (treeNode1, treeNode2) {\n        var minCorridorSize = this.CORRIDOR_WIDTH;\n        var corridorId;\n        var corridorX, corridorY, corridorWidth, corridorHeight;\n        // Тип разделения - сравним координаты x и y у зон\n        if (treeNode1.x === treeNode2.x) {\n            // вертикальное разделение - коридор рисуем вертикально\n            var top_1, bottom = void 0;\n            if (treeNode1.y < treeNode2.y) {\n                top_1 = treeNode1;\n                bottom = treeNode2;\n            }\n            else {\n                top_1 = treeNode2;\n                bottom = treeNode1;\n            }\n            var topRoom = top_1.getRoom();\n            var bottomRoom = bottom.getRoom();\n            // вычисляем позицию и размеры коридора между комнатами\n            corridorWidth = minCorridorSize;\n            var topRoomBottomY = topRoom.y + topRoom.height;\n            var bottomRoomTopY = bottomRoom.y;\n            // смещение центра коридора по Y, чтобы попасть на обе комнаты\n            corridorHeight = Math.max(bottomRoomTopY, topRoomBottomY) - Math.min(bottomRoomTopY, topRoomBottomY);\n            corridorY = topRoom.y + topRoom.height + (corridorHeight / 2);\n            var topRoomCenterX = topRoom.x + topRoom.width / 2;\n            var bottomRoomCenterX = bottomRoom.x + bottomRoom.width / 2;\n            var centerDiffX = Math.abs(topRoomCenterX - bottomRoomCenterX);\n            corridorX = Math.min(topRoomCenterX, bottomRoomCenterX) + centerDiffX / 2;\n            corridorId = topRoom.id + bottomRoom.id;\n            var newCoord = this.checkAndUpdateCorridorCoords(corridorX, corridorWidth, topRoom.x, topRoom.width, bottomRoom.x, bottomRoom.width);\n            corridorX = newCoord.coord;\n            corridorWidth = newCoord.size;\n        }\n        else {\n            // горизонтальное разделение - коридор горизонтальный\n            var left = void 0, right = void 0;\n            if (treeNode1.x < treeNode2.x) {\n                left = treeNode1;\n                right = treeNode2;\n            }\n            else {\n                left = treeNode2;\n                right = treeNode1;\n            }\n            var leftRoom = left.getRoom();\n            var rightRoom = right.getRoom();\n            // вычисляем позицию и размеры коридора между комнатами\n            corridorHeight = minCorridorSize;\n            var leftRoomRightX = leftRoom.x + leftRoom.width;\n            var rightRoomLeftX = (rightRoom.x);\n            // смещение центра коридора по X, чтобы попасть на обе комнаты\n            corridorWidth = Math.max(rightRoomLeftX, leftRoomRightX) - Math.min(rightRoomLeftX, leftRoomRightX);\n            corridorX = leftRoom.x + leftRoom.width + (corridorWidth / 2);\n            var leftRoomCenterY = leftRoom.y + leftRoom.height / 2;\n            var rightRoomCenterY = rightRoom.y + rightRoom.height / 2;\n            var centerDiffY = Math.abs(leftRoomCenterY - rightRoomCenterY);\n            corridorY = Math.min(leftRoomCenterY, rightRoomCenterY) + centerDiffY / 2;\n            corridorId = leftRoom.id + rightRoom.id;\n            var newCoord = this.checkAndUpdateCorridorCoords(corridorY, corridorHeight, leftRoom.y, leftRoom.height, rightRoom.y, rightRoom.height);\n            corridorY = newCoord.coord;\n            corridorHeight = newCoord.size;\n        }\n        var c = new Corridor_1.default(Math.floor(corridorX - corridorWidth / 2), Math.floor(corridorY - corridorHeight / 2), Math.floor(corridorWidth), Math.floor(corridorHeight));\n        c.id = corridorId;\n        return c;\n    };\n    BSPMazeGenerator.prototype.checkAndUpdateCorridorCoords = function (originCoord, originSize, coordRoom1, sizeRoom1, coordRoom2, sizeRoom2) {\n        // проверим - попал ли коридор на комнаты. Вдруг он сместился, нужно подвинуть\n        var coordMin = originCoord - originSize / 2;\n        var coordMax = originCoord + originSize / 2;\n        var newCorridorMaxX = coordMax, newCorridorMinX = coordMin;\n        if (coordMax > (coordRoom1 + sizeRoom1)) {\n            newCorridorMaxX = (coordRoom1 + sizeRoom1);\n        }\n        if (coordMax > (coordRoom2 + sizeRoom2)) {\n            newCorridorMaxX = (coordRoom2 + sizeRoom2);\n        }\n        if (coordMin < (coordRoom1)) {\n            newCorridorMinX = coordRoom1;\n        }\n        if (coordMin < coordRoom2) {\n            newCorridorMinX = coordRoom2;\n        }\n        // исправим положение коридора\n        if (originCoord < (newCorridorMinX + originSize / 2)) {\n            originCoord = newCorridorMinX + originSize / 2;\n        }\n        if (originCoord > (newCorridorMaxX - originSize / 2)) {\n            originCoord = (newCorridorMaxX - originSize / 2);\n        }\n        return { coord: originCoord, size: originSize };\n    };\n    return BSPMazeGenerator;\n}());\nexports.default = BSPMazeGenerator;\n\n\n//# sourceURL=webpack:///./src/lib/BSPMazeGenerator.ts?");

/***/ }),

/***/ "./src/lib/CellularAutomate.ts":
/*!*************************************!*\
  !*** ./src/lib/CellularAutomate.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SUPER_CELL = 9; // клетка в суперпозиции - может принять любое значение\nvar DEAD_CELL = 0; // точно мёртвая. Не изменит состояние при генерации\nvar LIVE_CELL = 1; // точно живая. Не изменит состояние при генерации\nvar SO_DEAD_CELL = 2; // условно мёртвая. Может изменить состояние на следующем шаге\nvar SO_LIVE_CELL = 3; // условно живая. --//--\nvar ZONE_PADDING = 2; // незаполняемый промежуток от границы зоны\nvar ROOM_FILL_MARGIN = 6; // промежуток вокруг комнаты для заполнения случайными клетками\nvar CellularAutomate = /** @class */ (function () {\n    function CellularAutomate(width, height, rooms, corridors) {\n        this.rooms = rooms;\n        this.corridors = corridors;\n        this.width = width;\n        this.height = height;\n        this.map = [];\n    }\n    // метод для пересчёта положения на карте в точке x,y в смещение в массиве\n    CellularAutomate.prototype.coordToOffset = function (x, y) {\n        return y * this.width + x;\n    };\n    // метод для пересчёта смещения в массиве в положение на карте в точке x,y\n    CellularAutomate.prototype.offsetToCoord = function (offset) {\n        var x = offset % this.width;\n        return { x: x, y: (offset - x) / this.width };\n    };\n    CellularAutomate.prototype.initializeMap = function () {\n        // TODO: 1. заливаем всю карту \"точно мёртвым\" цветом\n        // TODO: 2. проходим по комнатам и коридорам, заливаем место случайно вокруг них \"живыми\"\n        // TODO:    так чтобы на границах зон оставались \"точно мёртвые\" клетки\n        // TODO: 3. заливаем комнаты и коридоры \"точно живыми клетками\"\n        // TODO: 4. карта готова. Дальше отдельным методом прогоняем одну итерацию.\n        // TODO:    сколько итераций надо - решает внешний код\n        var _this = this;\n        // заполняем весь массив карты \"мёртвыми\" клетками\n        var mapSize = this.width * this.height;\n        for (var i = 0; i < mapSize; i++) {\n            this.map[i] = DEAD_CELL;\n        }\n        console.log(\"Map size: \" + mapSize + \", h: \" + this.height + \", w: \" + this.width);\n        // Далее проходим по всем комнатам, получаем из них зоны, и пространство вокруг\n        // комнаты заполняем клетками в суперпозиции. Аналогично - с коридорами\n        this.rooms.forEach(function (room) {\n            // берём границы, чтобы при заполнении пространства случайно не вылезти за зону\n            var minX = room.tree.x + ZONE_PADDING;\n            var maxX = room.tree.x + room.tree.width - ZONE_PADDING;\n            var minY = room.tree.y + ZONE_PADDING;\n            var maxY = room.tree.y + room.tree.height - ZONE_PADDING;\n            // теперь вокруг комнаты заполняем клетками\n            var fillX = room.x - ROOM_FILL_MARGIN;\n            var fillY = room.y - ROOM_FILL_MARGIN;\n            if (fillX < minX) {\n                fillX = minX;\n            }\n            if (fillY < minY) {\n                fillY = minY;\n            }\n            var fillMaxX = room.x + room.width + ROOM_FILL_MARGIN;\n            var fillMaxY = room.y + room.height + ROOM_FILL_MARGIN;\n            if (fillMaxX > maxX) {\n                fillMaxX = maxX;\n            }\n            if (fillMaxY > maxY) {\n                fillMaxY = maxY;\n            }\n            var roomX = room.x;\n            var roomMaxX = room.x + room.width;\n            var roomY = room.y;\n            var roomMaxY = room.y + room.height;\n            for (var i = fillX; i <= fillMaxX; i++) {\n                for (var j = fillY; j <= fillMaxY; j++) {\n                    // проверим, если это не внутри комнаты - то суперпозиция\n                    // если внутри - то живая клетка\n                    if (i >= roomX && i <= roomMaxX && j >= roomY && j <= roomMaxY) {\n                        _this.map[_this.coordToOffset(i, j)] = LIVE_CELL;\n                    }\n                    else {\n                        _this.map[_this.coordToOffset(i, j)] = SUPER_CELL;\n                    }\n                }\n            }\n        });\n        this.corridors.forEach(function (corridor) {\n            // теперь вокруг коридора заполняем клетками в суперпозиции\n            var fillX = corridor.x - ROOM_FILL_MARGIN;\n            var fillY = corridor.y - ROOM_FILL_MARGIN;\n            var fillMaxX = corridor.x + corridor.width + ROOM_FILL_MARGIN;\n            var fillMaxY = corridor.y + corridor.height + ROOM_FILL_MARGIN;\n            if (fillX < 0) {\n                fillX = 0;\n            }\n            if (fillY < 0) {\n                fillY = 0;\n            }\n            if (fillMaxX > _this.width) {\n                fillMaxX = _this.width;\n            }\n            if (fillMaxY > _this.height) {\n                fillMaxY = _this.height;\n            }\n            var roomX = corridor.x;\n            var roomMaxX = corridor.x + corridor.width;\n            var roomY = corridor.y;\n            var roomMaxY = corridor.y + corridor.height;\n            for (var i = fillX; i <= fillMaxX; i++) {\n                for (var j = fillY; j <= fillMaxY; j++) {\n                    if (_this.map[_this.coordToOffset(i, j)] === LIVE_CELL) {\n                        continue;\n                    }\n                    // проверим, если это не внутри коридора - то суперпозиция\n                    // если внутри - то живая клетка\n                    if (i >= roomX && i <= roomMaxX && j >= roomY && j <= roomMaxY) {\n                        _this.map[_this.coordToOffset(i, j)] = LIVE_CELL;\n                    }\n                    else {\n                        _this.map[_this.coordToOffset(i, j)] = SUPER_CELL;\n                    }\n                }\n            }\n        });\n        this.map.forEach(function (value, index, map) {\n            if (value === SUPER_CELL) {\n                map[index] = Math.random() > .5 ? SO_LIVE_CELL : SO_DEAD_CELL;\n            }\n        });\n    };\n    CellularAutomate.prototype.renderMap = function (graphics) {\n        var _this = this;\n        graphics.setDefaultStyles({\n            lineStyle: {\n                width: 1,\n                color: 0xFF0000,\n                alpha: 1\n            },\n            fillStyle: {\n                color: 0xFF0000,\n                alpha: 1\n            }\n        });\n        this.map.forEach(function (value, index) {\n            if (value === DEAD_CELL) {\n                return;\n            }\n            var color = 0XFFFFFF;\n            switch (value) {\n                case LIVE_CELL:\n                    color = 0xFFFFFF;\n                    break;\n                case SO_LIVE_CELL:\n                    color = 0xFFFFFF;\n                    break;\n                case SO_DEAD_CELL:\n                    color = 0x000000;\n                    break;\n            }\n            var point = _this.offsetToCoord(index);\n            graphics.fillStyle(color, 1);\n            graphics.fillPoint(point.x, point.y);\n        });\n    };\n    // прогоняет нужное количество итераций по подготовленной карте\n    CellularAutomate.prototype.run = function (iterations) {\n        if (iterations === void 0) { iterations = 1; }\n        iterations--;\n        // воспользуемся правилом отсюда: http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels\n        // 1. клетка становится стеной, если она была стеной и >=4 соседей были стенами\n        // 2. или клетка становится стеной, если она НЕ была стеной и >=5 соседей были стенами\n        var newMap = this.map;\n        var mapSize = this.width * this.height;\n        // для каких клеток есть смысл смотреть на соседей:\n        var minCellIndex = this.width + 2;\n        var maxCellIndex = mapSize - this.width - 2;\n        var _loop_1 = function (i) {\n            if (this_1.map[i] === DEAD_CELL || this_1.map[i] === LIVE_CELL) {\n                newMap[i] = this_1.map[i];\n                return \"continue\";\n            }\n            var isWasWall = this_1.map[i] === SO_DEAD_CELL;\n            // соберём \"соседей\" клетки на карте из массива\n            var neighbors = [\n                this_1.map[i - this_1.width - 1],\n                this_1.map[i - this_1.width],\n                this_1.map[i - this_1.width + 1],\n                this_1.map[i - 1],\n                this_1.map[i + 1],\n                this_1.map[i + this_1.width - 1],\n                this_1.map[i + this_1.width],\n                this_1.map[i + this_1.width + 1],\n            ];\n            var count = 0;\n            neighbors.forEach(function (value) {\n                if (value === DEAD_CELL || value === SO_DEAD_CELL) {\n                    count++;\n                }\n            });\n            if ((isWasWall && count >= 4) || (!isWasWall && count >= 5)) {\n                newMap[i] = SO_DEAD_CELL;\n            }\n            else {\n                newMap[i] = SO_LIVE_CELL;\n            }\n        };\n        var this_1 = this;\n        for (var i = minCellIndex; i < maxCellIndex; i++) {\n            _loop_1(i);\n        }\n        // новую карту посчитали, теперь перекладываем её в текущее состояние\n        this.map = newMap;\n        if (iterations > 0) {\n            this.run(iterations);\n        }\n    };\n    /**\n     * Возвращает текущее состояние карты в виде массива с двумя типами клеток: мёртвые или живые\n     */\n    CellularAutomate.prototype.getMap = function () {\n        var outMap = [];\n        for (var x = 0; x < this.width; x++) {\n            for (var y = 0; y < this.height; y++) {\n                var offset = this.coordToOffset(x, y);\n                var cell = this.map[offset];\n                var outVal = cell;\n                if (cell === SO_DEAD_CELL) {\n                    outVal = DEAD_CELL;\n                }\n                else if (cell === SO_LIVE_CELL) {\n                    outVal = LIVE_CELL;\n                }\n                outMap.push(outVal);\n            }\n        }\n        return outMap;\n    };\n    return CellularAutomate;\n}());\nexports.default = CellularAutomate;\n\n\n//# sourceURL=webpack:///./src/lib/CellularAutomate.ts?");

/***/ }),

/***/ "./src/lib/KeyGenerator.ts":
/*!*********************************!*\
  !*** ./src/lib/KeyGenerator.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar KeyGenerator = /** @class */ (function () {\n    function KeyGenerator() {\n    }\n    KeyGenerator.getNextKey = function (prefix) {\n        var keyToReturn;\n        if (prefix === undefined) {\n            keyToReturn = '' + KeyGenerator.key;\n            KeyGenerator.key++;\n            return keyToReturn;\n        }\n        if (!KeyGenerator.prefixedKeys.hasOwnProperty(prefix)) {\n            KeyGenerator.prefixedKeys[prefix] = 1;\n        }\n        keyToReturn = prefix + KeyGenerator.prefixedKeys[prefix];\n        KeyGenerator.prefixedKeys[prefix]++;\n        return keyToReturn;\n    };\n    KeyGenerator.resetAll = function () {\n        KeyGenerator.key = 1;\n        KeyGenerator.prefixedKeys = {};\n    };\n    KeyGenerator.key = 1;\n    KeyGenerator.prefixedKeys = {};\n    return KeyGenerator;\n}());\nexports.default = KeyGenerator;\n\n\n//# sourceURL=webpack:///./src/lib/KeyGenerator.ts?");

/***/ }),

/***/ "./src/lib/MathUtils.ts":
/*!******************************!*\
  !*** ./src/lib/MathUtils.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MathUtils = /** @class */ (function () {\n    function MathUtils() {\n    }\n    MathUtils.getRandomIntegerBetween = function (from, to) {\n        return Math.floor((Math.random() * (to - from + 1)) + from);\n    };\n    return MathUtils;\n}());\nexports.default = MathUtils;\n\n\n//# sourceURL=webpack:///./src/lib/MathUtils.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar GameScene_1 = __webpack_require__(/*! ./scenes/GameScene */ \"./src/scenes/GameScene.ts\");\nvar HelloScene_1 = __webpack_require__(/*! ./scenes/HelloScene */ \"./src/scenes/HelloScene.ts\");\nvar Center = Phaser.Scale.Center;\nvar GeneratorScene_1 = __webpack_require__(/*! ./scenes/GeneratorScene */ \"./src/scenes/GeneratorScene.ts\");\n// the game itself\nvar game;\nwindow.onload = function () {\n    var gameConfig = {\n        title: 'Sample',\n        type: Phaser.AUTO,\n        scale: {\n            width: 800,\n            height: 600,\n            autoCenter: Center.CENTER_BOTH\n        },\n        physics: {\n            default: 'arcade',\n            arcade: {\n                debug: true,\n            },\n        },\n        scene: [GeneratorScene_1.GeneratorScene, HelloScene_1.HelloScene, GameScene_1.GameScene],\n        parent: 'game',\n        backgroundColor: '#000000',\n        render: {\n            antialias: false,\n            antialiasGL: false,\n        }\n    };\n    game = new Phaser.Game(gameConfig);\n};\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/scenes/GameScene.ts":
/*!*********************************!*\
  !*** ./src/scenes/GameScene.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GameScene = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar Player_1 = __webpack_require__(/*! ../Player */ \"./src/Player.ts\");\nvar MathUtils_1 = __webpack_require__(/*! ../lib/MathUtils */ \"./src/lib/MathUtils.ts\");\nvar GameScene = /** @class */ (function (_super) {\n    __extends(GameScene, _super);\n    function GameScene() {\n        var _this = this;\n        var sceneConfig = {\n            active: false,\n            visible: false,\n            key: 'Game',\n        };\n        _this = _super.call(this, sceneConfig) || this;\n        return _this;\n    }\n    GameScene.prototype.preload = function () {\n        this.load.setBaseURL();\n        this.load.atlas('red_boat', 'assets/atlas/boatsSpriteListTransparent.png', 'assets/atlas/redBoatSpriteListConfig.json');\n        this.load.image('star', 'assets/star24.png');\n        // this.load.image('tilesExtruded', 'assets/tilemaps/WaterMazeTilesExtruded.png');\n        // this.load.tilemapTiledJSON('map', 'assets/tilemaps/WaterMazeMap.json');\n        this.load.image('tilesExtruded16', 'assets/tilemaps/WaterGrassTiles16Extruded.png');\n        this.load.tilemapTiledJSON('map', 'assets/tilemaps/WaterGrassMap16.json');\n    };\n    GameScene.prototype.create = function () {\n        var map = this.make.tilemap({ key: 'map' });\n        // The first parameter is the name of the tileset in Tiled and the second parameter is the key\n        // of the tileset image used when loading the file in preload.\n        // let tiles = map.addTilesetImage('waterAndGrass', 'tilesExtruded');\n        var tiles = map.addTilesetImage('waterAndGrass16', 'tilesExtruded16');\n        // You can load a layer from the map using the layer name from Tiled, or by using the layer\n        // index (0 in this case).\n        this.layer = map.createStaticLayer(0, tiles, 0, 0);\n        // TODO: научится бы корректно нужные спрайты для тайлов указывать.\n        // TODO: и соответственно - их проверять\n        map.setCollisionBetween(1, 1, true, false, this.layer);\n        // случайным образом генерим координаты и проверяем:\n        // если tail в этом месте не препятствие, то можно туда ставить звезду\n        this.stars = this.physics.add.group();\n        for (var i = 0; i < 10; i++) {\n            var tileX = void 0, tileY = void 0, placed = false;\n            do {\n                tileX = MathUtils_1.default.getRandomIntegerBetween(0, map.width - 1);\n                tileY = MathUtils_1.default.getRandomIntegerBetween(0, map.height - 1);\n                var tile = map.getTileAt(tileX, tileY);\n                if (tile.canCollide !== true) {\n                    // ставим на поле звёздочку\n                    placed = true;\n                    var coords = map.tileToWorldXY(tileX, tileY);\n                    this.stars.create(coords.x, coords.y, 'star');\n                }\n            } while (placed !== true);\n        }\n        console.log('STARS PLACED!');\n        this.player = new Player_1.Player(this, 200, 250);\n        //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function\n        this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);\n        this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);\n        this.cameras.main.setRoundPixels(true);\n        this.cameras.main.startFollow(this.player, true);\n        //  The score\n        this.collectedStars = 0;\n        this.scoreText = this.add.text(16, 16, \"\\u0421\\u043E\\u0431\\u0440\\u0430\\u043D\\u043E \\u0437\\u0432\\u0451\\u0437\\u0434: \" + this.collectedStars + \" \\u0438\\u0437 10\", { fontSize: '32px', fill: '#000' });\n        this.scoreText.setScrollFactor(0);\n    };\n    GameScene.prototype.update = function (time, delta) {\n        var cursorKeys = this.input.keyboard.createCursorKeys();\n        this.player.update(time, delta);\n        this.physics.collide(this.player, this.layer);\n    };\n    GameScene.prototype.collectStar = function (player, star) {\n        star.disableBody(true, true);\n        //  Add and update the score\n        this.collectedStars += 1;\n        this.scoreText.setText(\"\\u0421\\u043E\\u0431\\u0440\\u0430\\u043D\\u043E \\u0437\\u0432\\u0451\\u0437\\u0434: \" + this.collectedStars + \" \\u0438\\u0437 10\");\n        if (this.stars.countActive(true) === 0) {\n            this.scoreText.setText(\"\\u0421\\u043E\\u0431\\u0440\\u0430\\u043D\\u043E \\u0437\\u0432\\u0451\\u0437\\u0434: \" + this.collectedStars + \" \\u0438\\u0437 10\");\n            console.log('ALL STARS COLLECTED!!!');\n            //  A new batch of stars to collect\n            // this.stars.children.iterate(function (child) {\n            //\n            //     child.enableBody(true, child.x, 0, true, true);\n            //\n            // });\n            // var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);\n            //\n            // var bomb = bombs.create(x, 16, 'bomb');\n            // bomb.setBounce(1);\n            // bomb.setCollideWorldBounds(true);\n            // bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);\n            // bomb.allowGravity = false;\n        }\n    };\n    return GameScene;\n}(Phaser.Scene));\nexports.GameScene = GameScene;\n\n\n//# sourceURL=webpack:///./src/scenes/GameScene.ts?");

/***/ }),

/***/ "./src/scenes/GeneratorScene.ts":
/*!**************************************!*\
  !*** ./src/scenes/GeneratorScene.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeneratorScene = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar TextButton_1 = __webpack_require__(/*! ../Components/TextButton */ \"./src/Components/TextButton.ts\");\nvar Graphics = Phaser.GameObjects.Graphics;\nvar KeyGenerator_1 = __webpack_require__(/*! ../lib/KeyGenerator */ \"./src/lib/KeyGenerator.ts\");\nvar BSPMazeGenerator_1 = __webpack_require__(/*! ../lib/BSPMazeGenerator */ \"./src/lib/BSPMazeGenerator.ts\");\nvar GeneratorScene = /** @class */ (function (_super) {\n    __extends(GeneratorScene, _super);\n    function GeneratorScene() {\n        var _this = this;\n        var sceneConfig = {\n            active: false,\n            visible: false,\n            key: 'Generator'\n        };\n        _this = _super.call(this, sceneConfig) || this;\n        _this.MAP_WIDTH = 120;\n        _this.MAP_HEIGHT = 120;\n        _this.zones = [];\n        _this.rooms = [];\n        _this.corridors = [];\n        _this.debugMarks = [];\n        return _this;\n    }\n    GeneratorScene.prototype.preload = function () {\n    };\n    GeneratorScene.prototype.create = function () {\n        var _this = this;\n        this.mapGenerator = new BSPMazeGenerator_1.default();\n        this.mapGenerator.generateMap(this.MAP_WIDTH, this.MAP_HEIGHT);\n        this.zones = this.mapGenerator.getZones();\n        this.rooms = this.mapGenerator.getRooms();\n        this.corridors = this.mapGenerator.getCorridors();\n        // отрисуем зоны, комнаты из коридоры\n        this.drawMap();\n        // КНОПОЧКИ\n        // кнопочка перегенерации карты\n        this.generateButton = new TextButton_1.default(this, 5, 5, 'Generate');\n        this.generateButton.setFontSize(12).setDepth(10);\n        this.generateButton.on('pointerdown', function () { return _this.restartScene(); });\n        this.add.existing(this.generateButton);\n        // кнопочка скрыть/показать метки комнат и корридоров\n        this.showMarksButton = new TextButton_1.default(this, 70, 5, 'Show marks');\n        this.showMarksButton.setFontSize(12).setDepth(10);\n        this.showMarksButton.on('pointerdown', function () { return _this.toggleMarks(); });\n        this.add.existing(this.showMarksButton);\n        // кнопочка скачать скриншот\n        this.getScreenshotButton = new TextButton_1.default(this, 150, 5, 'Screenshot');\n        this.getScreenshotButton.setFontSize(12).setDepth(10);\n        this.getScreenshotButton.on('pointerdown', function () {\n            _this.game.renderer.snapshot(function (image) {\n                // console.log(image);\n                GeneratorScene.exportCanvasAsPNG('snapshot', image.src);\n            });\n        });\n        this.add.existing(this.getScreenshotButton);\n        // кнопочка запуска клеточного автомата\n        this.nextIterationButton = new TextButton_1.default(this, 250, 5, 'Iterate Map Filter');\n        this.nextIterationButton.setFontSize(12).setDepth(10);\n        this.nextIterationButton.on('pointerdown', function () {\n            _this.nextCellularAutomateIteration();\n        });\n        this.add.existing(this.nextIterationButton);\n        // кнопочка запуска клеточного автомата\n        var getDumpButton = new TextButton_1.default(this, 400, 5, 'Get dump')\n            .setFontSize(12)\n            .on('pointerdown', function () {\n            _this.getMapDump();\n        });\n        this.add.existing(getDumpButton);\n    };\n    GeneratorScene.prototype.restartScene = function () {\n        this.zones = [];\n        this.rooms = [];\n        this.corridors = [];\n        KeyGenerator_1.default.resetAll();\n        this.cellularAutomate = null;\n        this.mapGenerator = null;\n        this.scene.restart();\n    };\n    GeneratorScene.prototype.toggleMarks = function () {\n        var _this = this;\n        this.isDebugMarksVisible = !this.isDebugMarksVisible;\n        this.debugMarks.forEach(function (mark) {\n            mark.setVisible(_this.isDebugMarksVisible);\n        });\n    };\n    GeneratorScene.prototype.update = function (time, delta) {\n    };\n    GeneratorScene.exportCanvasAsPNG = function (fileName, dataUrl) {\n        var MIME_TYPE = \"image/png\";\n        var imgURL = dataUrl;\n        var dlLink = document.createElement('a');\n        dlLink.download = fileName;\n        dlLink.href = imgURL;\n        dlLink.dataset.downloadurl = [MIME_TYPE, dlLink.download, dlLink.href].join(':');\n        document.body.appendChild(dlLink);\n        dlLink.click();\n        document.body.removeChild(dlLink);\n    };\n    GeneratorScene.prototype.drawMap = function () {\n        var _this = this;\n        // и теперь для всех комнат и коридоров для дебага можно отрисовать их метки\n        // поверх уже нарисованной карты\n        // ЗОНЫ\n        // this.zones.forEach((tree: Tree) => {\n        //     // отрисуем зону\n        //     this.add.rectangle(\n        //         tree.x + (tree.width/2), tree.y + (tree.height/2),\n        //         tree.width - 2, tree.height - 2,\n        //         0x0000FF,\n        //         .2\n        //     );\n        //     this.add.text(\n        //         tree.x, tree.y,\n        //         `${tree.id}`\n        //     ).setColor('yellow').setFontSize(10);\n        // });\n        // КОМНАТЫ\n        this.rooms.forEach(function (room) {\n            // при отрисовке на поле, позиционирование происходит по центру спрайта/фигуры\n            _this.add.rectangle(room.x + (room.width / 2), room.y + (room.height / 2), room.width, room.height, 0xFFFFFF);\n            var mark = _this.add.text(room.x, room.y, \"\" + room.id).setColor('green').setFontSize(10).setVisible(_this.isDebugMarksVisible).setDepth(10);\n            _this.debugMarks.push(mark);\n        });\n        // КОРИДОРЫ\n        this.corridors.forEach(function (corridor) {\n            _this.add.rectangle(corridor.x + (corridor.width / 2), corridor.y + (corridor.height / 2), corridor.width, corridor.height, 0xFFFFFF);\n            var mark = _this.add.text(corridor.x + corridor.width / 2, corridor.y + corridor.height / 2, \"\" + corridor.id).setColor('black').setBackgroundColor('yellow').setFontSize(10).setVisible(_this.isDebugMarksVisible).setDepth(10);\n            _this.debugMarks.push(mark);\n        });\n    };\n    /**\n     * Запускаем итерации клеточного автомата по нашей карте\n     */\n    GeneratorScene.prototype.nextCellularAutomateIteration = function () {\n        if (this.graphicsForMap instanceof Graphics) {\n            this.graphicsForMap.clear();\n            this.mapGenerator.runFilterIteration();\n            this.mapGenerator.renderMap(this.graphicsForMap);\n        }\n        else {\n            this.graphicsForMap = this.add.graphics();\n            this.mapGenerator.renderMap(this.graphicsForMap);\n        }\n    };\n    GeneratorScene.prototype.getMapDump = function () {\n        var map = this.mapGenerator.getMap();\n        console.log('MAP DUMP: ', map.slice(0, 10));\n        var textarea = document.getElementById('textarea');\n        if (!textarea) {\n            textarea = document.createElement('textarea');\n            textarea.setAttribute('id', 'textarea');\n        }\n        textarea.cols = 150;\n        textarea.rows = 10;\n        textarea.value = map.toString();\n        document.body.append(textarea);\n    };\n    return GeneratorScene;\n}(Phaser.Scene));\nexports.GeneratorScene = GeneratorScene;\n\n\n//# sourceURL=webpack:///./src/scenes/GeneratorScene.ts?");

/***/ }),

/***/ "./src/scenes/HelloScene.ts":
/*!**********************************!*\
  !*** ./src/scenes/HelloScene.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HelloScene = void 0;\nvar Phaser = __webpack_require__(/*! phaser */ \"./node_modules/phaser/dist/phaser.js\");\nvar SelectGameButton_1 = __webpack_require__(/*! ../Components/SelectGameButton */ \"./src/Components/SelectGameButton.ts\");\nvar HelloScene = /** @class */ (function (_super) {\n    __extends(HelloScene, _super);\n    // private menuGeneratorLink: Phaser.GameObjects.Text;\n    function HelloScene() {\n        var _this = this;\n        var sceneConfig = {\n            active: false,\n            visible: false,\n            key: 'Hello',\n        };\n        _this = _super.call(this, sceneConfig) || this;\n        return _this;\n    }\n    HelloScene.prototype.preload = function () {\n    };\n    HelloScene.prototype.create = function () {\n        var _this = this;\n        var centerX = this.game.scale.width / 2;\n        var centerY = this.game.scale.height / 2;\n        var header = this.add.text(centerX, 20, 'Выбери что будешь делать');\n        header.setFontStyle('bold')\n            .setFontSize(16)\n            .setX(centerX - Math.round(header.width / 2));\n        // КНОПОЧКИ\n        // кнопочка перегенерации карты\n        var goSearchBoxGame = new SelectGameButton_1.default(this, 150, 100, 100, 100, 'Искать клады');\n        goSearchBoxGame.on('pointerdown', function () {\n            _this.scene.start('Game');\n        });\n        this.add.existing(goSearchBoxGame);\n        // // Выбор сцены. Переход на генератор\n        // this.menuGeneratorLink = this.add.text(10, 10, 'Map generator')\n        //     .setColor('black')\n        //     .setInteractive({useHandCursor: true})\n        //     .on('pointerover', () => this.hoverText())\n        //     .on('pointerout', () => this.outText())\n        //     .on('pointerdown', () => this.clickText());\n        // Нарисуем кнопку, при клике - вызываем сцену игры\n        // this.button = this.add.circle(centerX, centerY, 25, 0x00FF00)\n        //     .setInteractive({useHandCursor: true})\n        //     .on('pointerover', () => this.hoverButton())\n        //     .on('pointerout', () => this.outButton())\n        //     .on('pointerdown', () => this.clickButton());\n        //\n        // this.add.polygon(centerX + 2, centerY + 15, [\n        //     0,-15, 0,15, 20,0,\n        // ], 0x000000);\n    };\n    HelloScene.prototype.hoverButton = function () {\n        this.button.setFillStyle(0xFFFF00);\n    };\n    HelloScene.prototype.outButton = function () {\n        this.button.setFillStyle(0x00FF00);\n    };\n    HelloScene.prototype.clickButton = function () {\n        this.scene.start('Game');\n    };\n    // private hoverText() {\n    //     this.menuGeneratorLink.setShadow(0, 0, 'black', 5);\n    // }\n    //\n    // private outText() {\n    //     this.menuGeneratorLink.setShadow(0, 0, 'white', 0);\n    // }\n    HelloScene.prototype.clickText = function () {\n        this.scene.start('Generator');\n    };\n    HelloScene.prototype.update = function (time, delta) {\n    };\n    return HelloScene;\n}(Phaser.Scene));\nexports.HelloScene = HelloScene;\n\n\n//# sourceURL=webpack:///./src/scenes/HelloScene.ts?");

/***/ })

/******/ });